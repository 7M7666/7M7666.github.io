# Attacklab


<!--more-->
# 深入CS:APP Attack Lab
作为计算机系统基础的核心实验与期末考试高频考点，CS:APP的Attack Lab让我彻底跳出高级语言抽象层，直面IA-32架构底层逻辑。从简单栈溢出跳转，到应对地址随机化的ROP高级攻击，五个阶段的攻关不仅锤炼了硬核技能，更完成了从"写代码"到"懂机器"的思维蜕变。本文将实战思路、踩坑经历与期末必考知识点深度融合，既还原攻击实现细节，又明确考点方向，助力备考与实战双重需求。

## 一、实验核心背景与期末考点框架
### 1. 实验核心目标
对`ctarget`（无栈保护）和`rtarget`（栈不可执行+地址随机化）实施攻击，利用**栈溢出漏洞**篡改栈帧数据，劫持程序执行流，成功调用`touch1/touch2/touch3`函数。

### 2. 核心价值与期末必考维度
| 核心维度       | 实验核心价值                                                                 | 期末考试高频考点                                                                 |
|----------------|------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| 架构与ABI规则  | 理解x86-64栈布局、函数调用约定                                              | x86-64栈帧结构、寄存器传参规则、栈对齐要求、小端序存储                          |
| 攻击技术       | 掌握代码注入、ROP攻击等底层攻击手段                                          | 代码注入原理、ROP攻击逻辑、Gadget选型与链构造、相对定位绕过ASLR                  |
| 防御机制       | 认知系统安全防护的核心逻辑                                                  | NX/DEP（栈不可执行）、ASLR（地址随机化）、Stack Canary（栈Cookie）、RELRO          |
| 工具实操       | 熟练使用GDB、objdump等底层工具                                              | GDB调试核心命令、objdump反汇编与Gadget搜索、hex2raw工具用途                      |
| 错误分析       | 排查栈操作、内存布局相关问题                                                | 栈对齐失败、小端序错误、内存覆盖问题、ROP链偏移计算错误的排查                   |

## 二、分Level实战拆解+期末考点深度补充
### Level 1：入门级栈溢出——覆盖返回地址（期末基础必考题）
#### 目标
让`getbuf`执行完`ret`后，跳转到`touch1`而非原调用者`test`。

#### 核心实战思路
1. **定位目标地址**：通过GDB调试命令`p touch1`，获取`touch1`内存地址`0x4017c0`。
2. **计算填充长度**：分析`getbuf`汇编代码`sub $0x28, %rsp`，可知缓冲区大小为40字节（0x28转十进制），需先填充40字节垃圾数据占满缓冲区。
3. **处理字节序**：x86-64为小端序存储，需将地址`0x4017c0`反序拆分为`c0 17 40 00`，作为第41-48字节覆盖返回地址。
4. **生成攻击数据**：将十六进制数据写入`exploit.txt`，通过`./hex2raw < exploit.txt > ans.txt`转换为二进制流，传入`ctarget`执行攻击。

#### 期末补充考点（必考）
1. **x86-64栈帧结构（画图/计算题）**
   - 栈帧组成（高地址→低地址）：`调用者栈帧（保存的RBP、局部变量）→ 被调用者栈帧（局部变量/缓冲区 → 保存的RBP → 返回地址）`
   - 填充长度计算关键：实验中`getbuf`未使用RBP（编译器优化），故直接填充40字节覆盖返回地址；若函数保留RBP（`push %rbp; mov %rsp, %rbp`），则填充长度=缓冲区大小+8字节（保存的RBP），否则会覆盖错误位置。
   - 考试题型：给定函数汇编（含`sub $0xXX, %rsp`和帧指针操作），计算覆盖返回地址需填充的字节数。

2. **小端序存储（填空题）**
   - 定义：多字节数据的**低位字节存低地址，高位字节存高地址**。
   - 考点实例：64位地址`0x00000000004017c0`，写入栈时需为`c0 17 40 00 00 00 00 00`；易错点为误写为大端序`00 00 00 00 00 40 17 c0`，导致跳转至无效地址。

3. **工具命令考点（实操题）**
   - GDB核心命令：`p 函数名`（查符号地址）、`info functions 函数名`（查函数详情）、`b 函数名`（设断点）。
   - objdump反汇编：`objdump -d ctarget > ctarget.asm`（导出汇编代码，分析栈分配）。

#### 关键知识点（实验+考试重合点）
- 栈溢出本质：利用函数不检查输入长度的漏洞，覆盖栈上返回地址。
- 小端序规则：地址写入栈时必须字节反序，是后续所有实验的基础考点。

### Level 2：代码注入+传参——攻克栈对齐陷阱（ABI规则核心考点）
#### 目标
跳转到`touch2`，并将个人Cookie（`0x59b997fa`）传入`%rdi`寄存器（x86-64函数第一个参数默认寄存器）。

#### 核心实战思路
1. **定位关键地址**：
   - 用`objdump`反汇编获取`touch2`入口地址`0x4017ec`。
   - GDB在`getbuf`设断点，查看`$rsp`得到栈顶地址`0x5561dca0`（注入代码起始位置）。
2. **编写注入汇编（踩坑与优化）**：
   - 初始方案：`mov $0x59b997fa, %rdi; ret`，机器码`48 c7 c7 fa 97 b9 59 c3`。
   - 问题：`ret`跳转后栈指针移动8字节，破坏16字节栈对齐规则，导致`touch2`崩溃（Segmentation Fault）。
   - 优化方案：`mov $0x59b997fa, %rdi; push $0x4017ec; ret`，通过`push+ret`组合修正栈指针，既实现跳转又满足对齐要求。
3. **构造攻击数据**：13字节注入代码+填充数据+覆盖返回地址（指向注入代码起始地址`0x5561dca0`）。

#### 期末补充考点（高频简答题+计算题）
1. **x86-64 ABI核心规则（简答题）**
   - 寄存器传参规则：前6个参数依次存入`%rdi、%rsi、%rdx、%rcx、%r8、%r9`，第7个及以后参数压栈（栈传参从右向左）。
   - 栈对齐要求：**函数调用时（`call`指令执行后），%rsp必须是16字节的整数倍**。
     - 原理：`call`指令压入8字节返回地址，因此被调用者执行时`%rsp`（指向返回地址）需满足`%rsp mod 16 == 8`，执行`push %rbp`后`%rsp mod 16 == 0`，确保局部变量分配对齐。
     - 实验错误分析：初始方案`mov+ret`跳转后，`%rsp`=原栈顶+8，导致`touch2`调用时`%rsp mod 16 = 8`，违反ABI规则触发崩溃。

2. **汇编指令细节（指令分析题）**
   - `push $0x4017ec; ret`的栈操作：`push`使`%rsp -= 8`（压入目标地址），`ret`使`%rsp += 8`（弹出地址跳转），最终`%rsp`回到对齐状态。
   - 机器码转换：汇编`mov $0x59b997fa, %rdi`对应机器码`48 c7 c7 fa 97 b9 59`，其中`48`表示64位操作数（`movq`），`c7 c7`是`mov rdi, imm64`的操作码。
   - 考试题型：给定汇编指令写出机器码，或给定机器码反推汇编指令。

3. **防御机制考点：NX/DEP（简答题）**
   - 原理：CPU标记栈内存为“不可执行”，阻止注入代码运行（`rtarget`启用，`ctarget`未启用）。
   - 考试提问：为何Level 2的代码注入在`rtarget`中失效？如何绕过？（答案：NX阻止栈执行，需用ROP攻击利用现有代码段指令）。

#### 踩坑与解决方案（期末案例分析题）
- 核心坑点：x86-64 ABI的16字节栈对齐要求，容易被忽略。
- 解决思路：避免直接`ret`跳转，用`push`目标地址再`ret`的方式，手动修正栈指针偏移量。

### Level 3：字符串指针传递——内存布局的博弈（栈布局必考）
#### 目标
调用`touch3`，传入Cookie对应的十六进制字符串指针（而非直接传数值）。

#### 核心实战思路
1. **Cookie字符串转换**：将`0x59b997fa`转为ASCII码字符串（如`35 39 62 39 39 37 66 61`）。
2. **安全存储字符串（规避覆盖陷阱）**：
   - 陷阱：若字符串存于缓冲区（栈顶附近），`touch3`调用`hexmatch`时会压栈覆盖字符串。
   - 解决方案：利用栈向低地址生长的特性，将字符串藏在返回地址的"大后方"（`0x5561dca8`，即返回地址+8字节），该区域属于`getbuf`调用者栈帧，不会被覆盖。
3. **编写注入汇编**：`lea 0x5561dca8, %rdi; push $0x4018fa; ret`（加载字符串地址到`%rdi`，跳转`touch3`）。
4. **组装攻击数据**：注入代码+填充数据+返回地址（指向注入代码）+ Cookie字符串（存于`0x5561dca8`）。

#### 期末补充考点（计算题+简答题）
1. **栈生长方向与内存覆盖（计算题）**
   - 栈生长方向：**向低地址生长**（局部变量分配、函数调用压栈时`%rsp`递减）。
   - 安全区域计算：缓冲区起始`0x5561dc78`（高地址），大小40字节→缓冲区末端`0x5561dca0`（低地址），返回地址存于`0x5561dca0`，字符串存于`0x5561dca8`（更高地址，属于调用者栈帧）。
   - 考试题型：给定缓冲区起始地址`0x1000`、大小40字节，计算返回地址位置、字符串安全存储地址，并说明原因。

2. **字符串指针传递的本质（简答题）**
   - `touch3`要求`%rdi`存储字符串的**有效内存地址**，且该地址在`hexmatch`执行期间需保持数据完整。
   - 易错点：直接将Cookie值`0x59b997fa`存入`%rdi`，导致`hexmatch`访问无效内存触发段错误。

3. **Stack Canary防御机制（关联考点）**
   - 原理：编译器在返回地址前插入随机值（Canary），函数返回前检查Canary是否被篡改，若修改则触发崩溃（防止栈溢出覆盖返回地址）。
   - 考试提问：若`ctarget`启用Stack Canary，Level 1-3的攻击会如何失效？如何绕过？（答案：覆盖返回地址时破坏Canary，触发崩溃；绕过需泄露Canary值或利用ROP篡改Canary）。

#### 关键知识点（实验+考试重合点）
- 函数调用的栈帧影响：子函数压栈会覆盖低地址数据，需提前规划数据存储的安全区域。
- 字符串指针传递：需确保指针指向的内存区域在函数执行期间不被篡改。

### Level 4：ROP攻击入门——栈不可执行下的"借刀杀人"（ROP核心考点）
#### 目标
在`rtarget`（栈不可执行）中重现Level 2效果，不能注入新代码，仅利用程序现有指令片段（Gadget）。

#### 核心实战思路
1. **ROP核心逻辑**：寻找程序中以`ret`结尾的指令片段（Gadget），通过栈布局串联这些片段，实现参数传递和跳转。
2. **寻找关键Gadget**：
   - 需求：需`pop %rdi; ret`指令（将栈中数据弹入`%rdi`传参）。
   - 查找：通过`objdump -d rtarget | grep -A1 "ret" | grep -B1 "pop %rdi"`，找到该Gadget地址`0x40141b`（字节序列`5f c3`）。
3. **构造ROP链（栈对齐优化）**：
   - 初始方案：填充数据 → `pop %rdi; ret`（`0x40141b`） → Cookie → `touch2`地址。
   - 问题：栈指针移动24字节（`getbuf`返回8+`pop`8+`ret`8），非16的倍数，栈对齐失败。
   - 优化方案：链首插入空Gadget`ret`（地址`0x40141c`），多移动8字节，总偏移量32字节（16的倍数）。
4. **最终ROP链**：填充数据 → `ret`（`0x40141c`） → `pop %rdi; ret`（`0x40141b`） → Cookie → `touch2`地址。

#### 期末补充考点（选择题+计算题）
1. **Gadget定义与分类（选择题/简答题）**
   - 定义：程序代码段中以`ret`结尾的指令序列，是ROP攻击的"基本积木"。
   - 分类：
     - 寄存器操作Gadget：`pop %rdi; ret`（寄存器赋值）、`mov %rax, %rdi; ret`（寄存器搬运）。
     - 算术运算Gadget：`lea (%rdi, %rsi, 1), %rax`（加法）、`add %rax, %rdi; ret`（累加）。
     - 空操作Gadget：`ret`（仅修正栈指针，用于对齐）。

2. **ROP链栈对齐计算（计算题）**
   - 实验链偏移计算（从`getbuf`执行`ret`开始）：
     1. `getbuf` ret：弹出返回地址（ret Gadget），`%rsp +=8`（总偏移+8）。
     2. 执行ret Gadget：弹出自身地址，`%rsp +=8`（总偏移+16）。
     3. 执行`pop %rdi; ret`：`pop` Cookie（`%rsp +=8`），`ret`弹出`touch2`地址（`%rsp +=8`），总偏移+32。
     4. 调用`touch2`：`%rsp`为32字节（16的倍数），满足对齐要求。
   - 考试题型：给定ROP链（含n个Gadget和参数），计算执行后`%rsp`偏移量，判断是否满足16字节对齐。

3. **NX/DEP防御机制（简答题）**
   - 全称：No-eXecute/Data Execution Prevention（不可执行/数据执行保护）。
   - 原理：数据段（栈、堆）标记为"不可执行"，代码段标记为"只读"，阻止注入代码执行。
   - 绕过方式：ROP攻击（利用代码段中已有的可执行指令片段组合逻辑）。

#### 关键知识点（实验+考试重合点）
- 栈不可执行保护的核心作用：阻断代码注入攻击，迫使攻击者转向ROP技术。
- ROP链构造核心：通过栈布局控制指令执行顺序，用现有Gadget组合实现复杂逻辑。

### Level 5：地狱模式——ASLR下的相对定位ROP（期末压轴题）
#### 目标
在`rtarget`（开启ASLR地址随机化）中调用`touch3`，栈基址每次运行变化，无法使用绝对地址。

#### 核心实战思路
1. **破局关键**：ASLR仅改变栈基址，字符串与当前栈顶的**相对偏移量恒定**，核心公式：`目标地址 = 当前%rsp + 偏移量`。
2. **寻找计算型Gadget**：找到`lea (%rdi, %rsi, 1), %rax`（利用内存寻址完成`rax = rdi + rsi`，实现基址+偏移加法）。
3. **构建数据传送带（解决寄存器赋值问题）**：
   - 问题：无直接给`%rsi`赋值的Gadget。
   - 解决方案：`pop %rax → mov %eax, %edx → mov %edx, %ecx → mov %ecx, %esi`，将偏移量从栈传递到`%rsi`。
4. **捕获栈基址**：利用`mov %rsp, %rax → mov %rax, %rdi`，将当前栈顶地址存入`%rdi`（加法基址）。
5. **精确计算偏移量**：从获取栈指针到字符串存储位置，共9个8字节单位，偏移量`0x48`（72字节）。
6. **最终ROP链**：填充数据 → 偏移量`0x48` → 数据传送带Gadget → 栈基址捕获Gadget → 加法Gadget → 传参Gadget → `touch3`地址 → Cookie字符串。

#### 期末补充考点（综合题+计算题）
1. **ASLR原理与作用范围（简答题）**
   - 原理：每次程序运行时，操作系统随机化栈基址、堆基址、共享库加载地址，使攻击者无法预测绝对地址。
   - 核心漏洞：相对偏移不受基址随机化影响（如字符串与当前`%rsp`的距离固定），是相对定位的核心依据。
   - 考试提问：ASLR对Level 3的攻击为何有效？Level 5如何绕过？（答案：Level 3依赖绝对地址，ASLR使地址失效；Level 5利用相对偏移恒定实现绕过）。

2. **ROP链构造进阶（综合题）**
   - 多参数传递思路：调用`func(a,b,c)`需构造链：`ret（对齐）→ pop %rdi; ret → a → pop %rsi; ret → b → pop %rdx; ret → c → func地址`。
   - 实验链核心步骤（期末可能考链构造）：
     1. 读取偏移量：`pop %rax; ret` → 栈中存入`0x48`。
     2. 寄存器搬运：`mov %eax, %edx; ret` → `mov %edx, %ecx; ret` → `mov %ecx, %esi; ret`（偏移量传入`%rsi`）。
     3. 捕获栈基址：`mov %rsp, %rax; ret` → `mov %rax, %rdi; ret`（栈顶地址传入`%rdi`）。
     4. 计算目标地址：`lea (%rdi, %rsi, 1), %rax; ret`（`rax = 栈基址 + 偏移量`）。
     5. 传参调用：`mov %rax, %rdi; ret` → `touch3`地址（字符串地址传入`%rdi`）。

3. **偏移量计算（计算题）**
   - 实验`0x48`（72字节）计算逻辑：
     偏移量= 3个mov Gadget（3×8=24）+ pop偏移量（8）+ 栈基址捕获Gadget（2×8=16）+ 加法Gadget（8）+ 传参Gadget（8）+ 字符串与最后一个Gadget的距离（8）= 72字节。
   - 考试题型：给定ROP链组件（Gadget、参数、数据存储位置），计算所需相对偏移量。

4. **RELRO防御机制（关联考点）**
   - 原理：Relocation Read-Only（重定位只读），将全局偏移表（GOT）标记为只读，防止篡改GOT表劫持函数调用。
   - 考试提问：若`rtarget`启用Full RELRO，对ROP攻击有何影响？（答案：不影响ROP链构造，因ROP利用代码段指令；但阻止GOT劫持攻击）。

#### 踩坑与解决方案（期末案例分析题）
- 核心坑点：偏移量计算错误，导致指针指向无效内存，前功尽弃。
- 解决思路：逐行梳理ROP链栈布局，精确统计每个Gadget和数据占用的8字节单位数，像解数学题一样推导偏移量。

## 三、实验核心收获与期末总复习清单

### 期末总复习核心清单
#### （1）必须掌握的底层原理
- x86-64栈帧结构（会画图、能计算地址）。
- 小端序存储规则（会转换地址字节序列）。
- x86-64 ABI（寄存器传参、栈对齐）。
- 三大防御机制：NX/DEP、ASLR、Stack Canary（原理+绕过方式）。

#### （2）必须掌握的工具命令
| 工具    | 核心命令                                  | 用途                                  |
|---------|-------------------------------------------|---------------------------------------|
| GDB     | `p 函数名`、`info registers`、`x/10x $rsp`、`b 函数名` | 调试、地址获取、栈帧查看              |
| objdump | `objdump -d 程序名`、`grep "ret" 汇编文件` | 反汇编、Gadget搜索                    |
| hex2raw | `./hex2raw < exploit.txt > ans.txt`       | 十六进制→二进制转换                   |

#### （3）常见错误与排查（案例分析题必考）
- 小端序错误：地址写入顺序颠倒，跳转无效地址。
- 栈对齐失败：ROP链偏移量非16的倍数，触发段错误。
- 内存覆盖：字符串存储位置不当，被函数调用压栈覆盖。
- 偏移量计算错误：相对定位时指针指向无效内存。



---

> Author: 7M7  
> URL: http://localhost:1313/posts/02fead5/  

