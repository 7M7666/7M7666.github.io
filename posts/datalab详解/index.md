# DataLab详解

# DataLab 位运算实验详解

## 实验概述

**实验目的：** 熟悉和掌握计算机中整数和浮点数的二进制编码表示

**实验环境：** C语言编程环境

**实验时间：** 2025年10月23日

---


## 实验内容详解

### 第1关：bitAnd - 位与运算

#### 知识点
- **德摩根定律：** `x & y = ~(~x | ~y)`
- **位运算基础：** 取反、或运算的应用

#### 任务要求
补充函数`bitAnd()`，只用`~`，`|`实现`x & y`

- **操作符限制：** `~`，`|`
- **操作符数量限制：** 8

#### 解题思路
根据德摩根定律，位与运算可以通过取反和或运算来实现：
1. 对x和y分别进行取反操作：`~x`，`~y`
2. 对两个结果进行按位或运算：`~x | ~y`
3. 对最终结果再次取反：`~(~x | ~y)`

#### 代码实现
```c
int bitAnd(int x, int y) {
    return ~(~x | ~y);
}
```

---

### 第2关：getByte - 字节提取

#### 知识点
- **字节编号：** 从低位到高位从0开始编号
- **位偏移计算：** 每个字节占8位，n号字节对应8n位偏移
- **掩码操作：** 使用`& 0xFF`提取最低8位

#### 任务要求
补充函数`getByte()`，取出x中的n号字节

- **字节编号：** 从低位到高位从0开始
- **操作符数量限制：** 6

#### 解题思路
1. 计算位偏移量：`n << 3`（相当于n * 8）
2. 将x右移相应位数：`x >> (n << 3)`
3. 使用掩码`0xFF`提取最低8位：`& 0xFF`

#### 代码实现
```c
int getByte(int x, int n) {
    return (x >> (n << 3)) & 0xFF;
}
```

#### 示例分析
对于x = 0x12345678：
- 字节3：0x12（最高位字节）
- 字节2：0x34
- 字节1：0x56
- 字节0：0x78（最低位字节）

提取字节1：`n << 3 = 8`，`x >> 8 = 0x00123456`，`& 0xFF = 0x56`

---

### 第3关：logicalShift - 逻辑右移

#### 知识点
- **逻辑右移：** 高位补0
- **算术右移：** 高位补符号位
- **掩码构造：** 生成合适的掩码来清除符号位扩展

#### 任务要求
补充函数`logicalShift()`，将x逻辑右移n位（0 ≤ n ≤ 31）

- **操作符数量限制：** 20

#### 解题思路
1. 生成基准高位标志：`1 << 31`（仅最高位为1）
2. 对标志进行算术右移n位：`(1 << 31) >> n`
3. 取反得到掩码：`~((1 << 31) >> n)`
4. 对x进行算术右移后与掩码结合：`(x >> n) & mask`

#### 代码实现
```c
	int m=1 << 31;
    m=~((m >> n) << 1);
    return (x >> n)& m;
```

---

### 第4关：bitCount - 位计数

#### 知识点
- **位统计：** 统计二进制表示中1的个数
- **位掩码：** 使用左移操作生成位掩码
- **循环思想：** 通过重复操作实现循环效果

#### 任务要求
补充函数`bitCount()`，统计x的二进制表示中1的数量

#### 解题思路
使用暴力方法，遍历每一位并统计1的个数：
1. 初始化计数器为0
2. 对于每一位i（0-31）：
   - 生成位掩码：`1 << i`
   - 与x进行与运算：`x & (1 << i)`
   - 如果结果非0，计数器加1

#### 代码实现
```c
    int ret = 0;
    for(int i=0; i<32; i++){  
        if(x & (1<<i)){       
            ret++;
        }
    }
    return ret;
```

---

### 第5关：bang - 逻辑非运算

#### 知识点
- **逻辑非特性：** !x在x为0时返回1，x非0时返回0
- **补码特性：** x和-x的符号位相反
- **符号位提取：** 通过右移31位提取符号位

#### 任务要求
补充函数`bang()`，实现逻辑非运算`!x`

- **操作符限制：** `~ & ^ | + << >>`
- **操作符数量限制：** 12

#### 解题思路
1. 利用补码特性：`x | (-x)`
   - 当x = 0时，结果为0
   - 当x ≠ 0时，结果的最高位为1
2. 提取符号位：`(x | (-x)) >> 31`
3. 调整结果：加1得到最终的逻辑非结果

#### 代码实现
```c
int bang(int x) {
    return ((x | (~x + 1)) >> 31) + 1;
}
```

#### 详细分析
- **x = 0：** `0 | 0 = 0`，`0 >> 31 = 0`，`0 + 1 = 1` → 正确
- **x ≠ 0：** `x | (-x)`最高位为1，`>> 31`得到-1，`-1 + 1 = 0` → 正确

---

### 第6关：tmin - 最小补码整数

#### 知识点
- **补码表示：** 32位补码的最小值为-2^31
- **位操作：** 通过左移操作生成最小值

#### 任务要求
补充函数`tmin()`，返回补码表示的整型最小值

- **操作符数量限制：** 4

#### 解题思路
32位补码的最小值是-2^31，其二进制表示为最高位1，其余位0。通过`1 << 31`可以直接生成这个值。

#### 代码实现
```c
int tmin(void) {
    return 1 << 31;
}
```

---

### 第7关：fitsBits - 位数适配检查

#### 知识点
- **补码范围：** n位补码的范围是[-2^(n-1), 2^(n-1)-1]
- **符号扩展：** 左移再右移可以检验是否在范围内

#### 任务要求
补充函数`fitsBits()`，如果x可以只用n位补码表示则返回1，否则返回0（1 ≤ n ≤ 32）

- **操作符数量限制：** 15

#### 解题思路
1. 计算移位量：`32 - n`
2. 左移后再右移：`(x << (32 - n)) >> (32 - n)`
3. 比较结果与原x是否相等：相等则在范围内

#### 代码实现
```c
int fitsBits(int x, int n) {
    return x == ((x << (32 - n)) >> (32 - n));
}
```

---

### 第8关：divpwr2 - 除以2的幂

#### 知识点
- **向零舍入：** 正数向下舍入，负数向上舍入
- **偏移量修正：** 负数需要添加**偏移量**来实现向零舍入

#### 任务要求
补充函数`divpwr2()`，计算x / 2^n，结果向零取整（0 ≤ n ≤ 30）

- **操作符数量限制：** 15

#### 解题思路
1. 生成偏移量：`(1 << n) - 1`
2. 提取符号位：`x >> 31`
3. 计算修正值：`(x >> 31) & ((1 << n) - 1)`
4. 加偏移量后右移：`(x + bias) >> n`

#### 代码实现
```c
int divpwr2(int x, int n) {
    int bias = (x >> 31) & ((1 << n) - 1);
    return (x + bias) >> n;
}
```

---

### 第9关：negate - 取负数

#### 知识点
- **补码取负：** 补码的负数等于取反加1
- **位运算实现：** `~x + 1`

#### 任务要求
补充函数`negate()`，计算-x

#### 解题思路
根据补码的特性，一个数的负数等于它的取反加1：`-x = ~x + 1`

#### 代码实现
```c
int negate(int x) {
    return ~x + 1;
}
```

---

### 第10关：isPositive - 正数判断

#### 知识点
- **符号位检查：** 最高位为0表示正数
- **非零检查：** 需要排除x = 0的情况

#### 任务要求
补充函数`isPositive()`，如果x大于0返回1，否则返回0

- **操作符数量限制：** 8

#### 解题思路
1. 检查符号位：`(x >> 31) & 1` → 0表示非负
2. 检查是否非零：`!!x` → 1表示非零
3. 两者结合：`(!((x >> 31) & 1)) & (!!x)`

#### 代码实现
```c
int isPositive(int x) {
    return !((x >> 31) & 1) & (!!x);
}
```

---

### 第11关：isLessOrEqual - 小于等于判断

#### 知识点
- **符号比较：** 不同符号的数比较
- **差值比较：** 相同符号的数通过差值比较

#### 任务要求
补充函数`isLessOrEqual()`，如果x小于等于y则返回1

- **操作符数量限制：** 24

#### 解题思路
1. **符号不同：**
   - x负y正 → x ≤ y → 返回1
   - x正y负 → x > y → 返回0
2. **符号相同：**
   - 计算y - x
   - 检查y - x的符号位

#### 代码实现
```c
	int x1=x>>31;
    int y1=y>>31;
    int case1=x1&!y1;//x负y正的情况

    int temp=y+~x+1; //y-x
    int case2=(!(temp>>31))&(!(x1^y1));//xy同号但是y-x大于0
    return case1|case2;
```

---

### 第12关：ilog2 - 以2为底的对数

#### 知识点
- **二进制最高位：** 找到最高位1的位置
- **二分查找：** 通过二分法快速定位最高位

#### 任务要求
补充函数`ilog2()`，返回x以2为底的对数的整数部分

#### 解题思路
使用二分法定位最高位1的位置：
1. 检查高16位是否有1
2. 检查高8位是否有1
3. 继续检查4位、2位、1位
4. 就是不断逼近逼近

#### 代码实现
```c
 int ret = 0;
    if (x >= (1 << 16)) { ret += 16; x >>= 16; }
    if (x >= (1 << 8))  { ret += 8;  x >>= 8;  }
    if (x >= (1 << 4))  { ret += 4;  x >>= 4;  }
    if (x >= (1 << 2))  { ret += 2;  x >>= 2;  }
    if (x >= (1 << 1))  { ret += 1;  x >>= 1;  }
    return ret;
```

---

### 第13关：float_neg - 浮点数取负

#### 知识点
- **IEEE 754浮点数：** 符号位、阶码、尾数三部分组成
- **符号位操作：** 取反符号位即可得到负数

#### 任务要求
补充函数`float_neg()`，返回-f的位级表示

#### 解题思路
1. 提取符号位：`uf >> 31`
2. 取反符号位：`1 ^ (uf >> 31)`
3. 重组浮点数：`(new_sign << 31) | (uf & 0x7FFFFFFF)`

#### 代码实现
```c
    unsigned int jieshu=(uf>>23)&0xFF;
    unsigned int weishu=uf&0x7FFFFF;
    if(jieshu==0xFF&weishu!=0) return uf;//NaN是阶数全是1，尾数不全为0，全为0是无穷大
    return uf^(1<<31);//取反符号位 
```

---

### 第14关：float_i2f - 整数转浮点数

#### 知识点
- **IEEE 754标准：** 单精度浮点数格式
- **规格化表示：** 1.xxxx × 2^exp
- **舍入处理：** 需要考虑截断误差

#### 任务要求
补充函数`float_i2f()`，实现由int到float的类型转换

- **操作符数量限制：** 30

#### 解题思路
1. **处理特殊情况：** x = 0
2. **处理符号：** 记录符号位，取绝对值
3. **定位最高位：** 找到最高位1的位置
4. **计算阶码：** exp = 127 + 最高位位置
5. **提取尾数：** 取中间23位
6. **舍入处理：** 根据截断部分进行舍入

#### 代码实现
```c
    unsigned sign=0,enow=0,fnow=0,abx=x,
    shiftleft=0,tail=0,result=0;
    unsigned pos=1<<31;//制造符号为1的掩码
    if(x==0){
        return 0;
    }
    if(x<0){
        abx=-x;
        sign=pos;//符号位1
    }
    while((abx&pos)==0)
    {
        abx<<=1;
        shiftleft++;找到最左边是1
    }
    enow=127+31-shiftleft;//31-shiftleft就是阶数
    tail=abx&0xFF;
    fnow=(abx>>8)&(~(pos>>8));//取后23
    result=sign|(enow<<23)|fnow;
    if(tail>0x80)
    {
        result+=1;
    }else if(tail==0x80)
    {
        if(fnow&1)
        {
            result+=1;
        }
    }
    return result;

}
```

---

### 第15关：float_twice - 浮点数乘以2

#### 知识点
- **浮点数乘法：** 乘以2相当于指数加1
- **特殊情况处理：** 非规格化数、无穷大、NaN

#### 任务要求
补充函数`float_twice()`，返回2*f的位级表示

- **操作符数量限制：** 30

#### 解题思路
1. **提取各部分：** 符号位、阶码、尾数
2. **处理非规格化数：** 尾数左移1位，无限逼近于0
3. **处理无穷大/NaN：** 直接返回原数，他们共享一个特性，就是阶数全是1
4. **处理正常数：** 阶码加1

#### 代码实现
```c
    unsigned int s =uf>>31;
    unsigned int jieshu=(uf>>23)&0xFF;
    unsigned int weishu=uf&0x7FFFFF;
    if(jieshu==0){
        return (s << 31) | (0 << 23) | (weishu << 1);
    }else if(jieshu==0xFF)
    {
        return uf;//nan和无穷大
    }else{
        jieshu+=1;
        if(jieshu==0xFF)
        {
            weishu=0;
        }
    }
    return s<<31|jieshu<<23|weishu;
```

---




---

> Author: 7M7  
> URL: http://localhost:1313/posts/datalab%E8%AF%A6%E8%A7%A3/  

