# 8086 汇编 + Debug 调试：TRUEAD 命令与常用指令系统笔记



---



# 8086 汇编 + Debug 调试：TRUEAD 命令与常用指令系统笔记




## 1. 8086 的基本“世界观”

### 1.1 字长与内存

* **字节（Byte）**：8 位，范围 0~255 (`00H ~ FFH`)
* **字（Word）**：16 位，由 2 个字节组成
* **8086 特性**：16 位 CPU
    * 寄存器宽度一般是 16 位
    * 部分寄存器可以拆成两个 8 位使用

**内存模型：**
内存可以想象成一条长长的字节数组：
* 每个“格子”存 1 个字节
* 每个格子有一个 **物理地址**：`0 ~ 1MB-1`（20 位地址线）

### 1.2 寄存器简表

* **通用寄存器（16 位）**：
    * `AX`, `BX`, `CX`, `DX`
    * **可拆分**：
        * `AX` = `AH` (高8位) + `AL` (低8位)
        * `BX` = `BH` + `BL`
        * `CX` = `CH` + `CL`
        * `DX` = `DH` + `DL`
* **段寄存器**：
    * `CS` (代码段), `DS` (数据段), `SS` (栈段), `ES` (附加段)
* **指令指针**：
    * `IP`：记录下一条要执行的指令在代码段中的**偏移量**
* **标志寄存器 (Flags)** - 重点记这几个：
    * **ZF (Zero Flag)**：结果为 0 置 1
    * **CF (Carry Flag)**：无符号运算进位/借位
    * **OF (Overflow Flag)**：有符号运算溢出
    * **SF (Sign Flag)**：结果最高位（符号位）

---

## 2. 寻址公式：逻辑地址 → 物理地址

8086 不直接操作物理地址，而是使用 **段地址 : 偏移地址 (Segment : Offset)**。

> **📐 计算公式**
>
> $$\text{物理地址} = \text{段地址} \times 16 + \text{偏移地址}$$
>
> 也就是：`Physical = (Segment << 4) + Offset`

**举例说明：**

* `1000:0000`
    * 物理地址 = $1000H \times 10H + 0000H$ = **10000H**
* `1000:0009`
    * 物理地址 = $1000H \times 10H + 0009H$ = **10009H**

**在 Debug 输出中的样子：**

```text
1000:0000  41 42 43 44 00 00 00 00-00 00 00 00 00 00 00 00  ABCD............
|-------|  |---------------------------------------------|  |--------------|
 段:偏移                  16个字节的十六进制数据                对应的 ASCII 字符
````

-----

## 3\. Debug 环境与进入方式

通常在 DOSBox 中运行：

```bash
C:\> debug
-
```

  * 看到一行 `-` 提示符表示进入 debug 模式。
  * **退出命令**：输入 `q` 回车。

-----

## 4\. TRUEAD + GQ：Debug 常用命令总览

**🔥 记忆口诀：TRUEAD + GQ**

| 命令 | 全称 | 作用 | 助记 |
| :---: | :--- | :--- | :--- |
| **T** | **T**race | 单步执行一条指令 | 跟踪 |
| **R** | **R**egister | 显示/修改寄存器 | 寄存器 |
| **U** | **U**nassemble | 反汇编机器码 | 反汇编 |
| **E** | **E**nter | 修改内存数据 | 输入/编辑 |
| **A** | **A**ssemble | 汇编指令到内存 | 汇编 |
| **D** | **D**ump | 显示内存内容 | 倒出(数据) |
| **G** | **G**o | 连续执行程序 | 运行 |
| **Q** | **Q**uit | 退出 debug | 退出 |

-----

## 5\. 命令详解

### 5.1 T：Trace —— 单步执行

**作用**：按“机器指令”为单位，一条条执行，观察寄存器、标志位变化。

**语法**：

```text
-t              ; 从当前 CS:IP 单步执行一条
-t=1000:0000    ; 从 1000:0000 单步执行一条
```

**常用 Debug 流程**：

1.  用 `u` 看某地址上的代码。
2.  用 `r` 查看当前 `CS:IP`。
3.  用 `t` 一条条执行。
4.  每步后系统会自动显示寄存器状态，观察 `AX`、标志位的变化。

-----

### 5.2 R：Register —— 查看/修改寄存器

**作用**：显示或修改 CPU 寄存器值。

**语法**：

```text
-r              ; 显示所有寄存器及标志位
-r ax           ; 显示 AX 一个寄存器（随后输入新值）
-r ip 0100      ; (部分版本支持) 修改指令指针 IP
```

**典型输出**：

```text
-r
AX=0000  BX=0000  CX=0000  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=0F00  ES=0F00  SS=0F00  CS=1A2B  IP=0100   NV UP EI PL NZ NA PO NC
```

> **注意**：最后一行大写字母是标志位状态。例如 `NZ` = Not Zero (ZF=0), `NC` = No Carry (CF=0)。

-----

### 5.3 U：Unassemble —— 反汇编代码

**作用**：把内存中的机器码反向翻译回汇编指令。

**语法**：

```text
-u              ; 从当前 CS:IP 开始反汇编
-u 1000:0000    ; 从 1000:0000 处反汇编
```

**示例**：

```assembly
1000:0000 B8E803       MOV AX,03E8
1000:0003 B364         MOV BL,64
1000:0005 F6F3         DIV BL
```

-----

### 5.4 E：Enter —— 修改内存数据

**作用**：从一个地址开始逐字节写入数据。

**语法**：

```text
-e 1000:0000 41 42 43 44    ; 写入十六进制
-e 1000:0000 'A' 'B' 'C'    ; 写入字符常量
```

-----

### 5.5 A：Assemble —— 汇编指令到内存

**作用**：直接输入汇编助记符，Debug 自动将其转为机器码。

**语法**：

```text
-a 1000:0000
1000:0000 mov ax, 1000
1000:0003 mov bl, 60
1000:0005 div bl
1000:0007 int 3          ; 常用 int 3 作为断点
1000:0008 <回车结束>
```

-----

### 5.6 D：Dump —— 查看内存内容

**作用**：以“十六进制 + ASCII”的形式显示内存。

**语法**：

```text
-d              ; 从当前 DS:offset 开始
-d 1000:0000    ; 从 1000:0000 显示一屏
```

-----

### 5.7 G：Go —— 连续执行程序

**作用**：全速运行，直到程序结束或遇到断点（如 `INT 3`）。

**语法**：

```text
-g              ; 从当前 CS:IP 跑
-g=1000:0000    ; 设定入口地址并运行
```

-----

## 6\. 核心指令与标志位实战

### 6.1 ADD & SUB：加减法

**示例 1：ADD 无溢出**

```assembly
mov al, 0F0h     ; AL = 240
add al, 0Ah      ; AL = 240 + 10 = 250 (FAH)
; 结果：CF=0, ZF=0
```

**示例 2：ADD 产生进位 (CF=1)**

```assembly
mov al, 0F0h     ; 240
add al, 20h      ; 240 + 32 = 272 (>255)
; 结果：AL=10H (溢出部分丢弃), CF=1
```

**示例 3：SUB 产生借位 (CF=1)**

```assembly
mov al, 20h      ; 32
sub al, 30h      ; 32 - 48
; 结果：AL=F0H, CF=1 (不够减，借位)
```

-----

### 6.2 DIV：无符号除法

DIV 指令根据除数的位数（8位或16位）有不同的行为：

| 除数位数 | 被除数位置 | 商存储位置 | 余数存储位置 |
| :--- | :--- | :--- | :--- |
| **8 位** (`reg/mem8`) | **AX** (16位) | **AL** | **AH** |
| **16 位** (`reg/mem16`) | **DX:AX** (32位) | **AX** | **DX** |

> **⚠️ 注意**：`DX:AX` 表示高 16 位存 DX，低 16 位存 AX。

**典型实验案例：**

1.  **8 位除法（整除）**

    ```assembly
    mov ax, 1000    ; 03E8H
    mov bl, 100     ; 64H
    div bl          ; 1000 / 100
    ; 结果：AL = 0Ah (10), AH = 00h (0)
    ```

2.  **8 位除法（有余数）**

    ```assembly
    mov ax, 1000
    mov bl, 60
    div bl
    ; 结果：AL = 10H (16), AH = 28H (40)
    ```

3.  **除法溢出 (Divide Error)**

      * 如果商超过了寄存器能表示的范围（例如 8 位除法商 \> 255），Debug 会报错 `Divide error`。

-----

## 7\. 综合实验模板

### 模板一：除法实验 (A + G + R)

```text
-a 1000:0
mov ax, 1000
mov bl, 60
div bl
int 3

-g=1000:0
-r
; 检查 AX 结果
```

### 模板二：内存读写实验 (D + E)

```text
-d 1000:0          ; 查看原始内容
-e 1000:0 'A' 'B' 'C'
-d 1000:0          ; 验证修改结果
```

### 模板三：单步跟踪 (A + T)

```text
-a 1000:0
mov al, F0
add al, 20
int 3

-r                 ; 看初始状态
-t=1000:0          ; 执行第一句
-r                 ; 检查
-t                 ; 执行第二句
-r                 ; 检查 CF 标志位
```

-----

## 8\. 总结

1.  **地址计算**：物理地址 = $段 \times 16 + 偏移$。
2.  **七大命令**：`T`(跟踪), `R`(寄存器), `U`(反汇编), `E`(改内存), `A`(写汇编), `D`(看内存), `G`(运行)。
3.  **DIV 规则**：
      * 除数 8 位 → 结果在 AX (商AL, 余AH)
      * 除数 16 位 → 结果在 AX, DX (商AX, 余DX)
4.  **标志位**：重点关注 **CF** (进位/借位) 和 **ZF** (零标志)。




---

> Author: 7M7  
> URL: http://localhost:1313/posts/017d598/  

