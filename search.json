[{"categories":["计算机基础","学习笔记"],"content":"深入理解计算机系统(CSAPP) Bomb Lab 实验的详细通关解析，涵盖汇编指令分析、GDB调试技巧及6个关卡的解题思路。","date":"2025-12-01","objectID":"/posts/bomblab/","tags":["CSAPP","汇编","Linux","GDB"],"title":"CSAPP Bomb Lab 详细解析与复习笔记","uri":"/posts/bomblab/"},{"categories":["计算机基础","学习笔记"],"content":"CSAPP Bomb Lab 复习笔记 一、实验简介：不止于“拆弹”的底层修炼 Bomb Lab 是《深入理解计算机系统》（CSAPP）第三章「程序的机器级表示」的核心配套实验。实验核心是通过反汇编二进制程序 bomb，分析 x86-64 汇编代码的逻辑，推断出 6 个“炸弹阶段”的输入字符串，解除炸弹。 实验价值： 不是死记硬背答案，而是掌握「汇编指令解析」「栈帧结构」「函数调用约定」「控制流（循环、switch、递归、链表）底层实现」等核心知识； 熟练使用 GDB 调试工具，建立“代码-汇编-内存”的映射思维，为后续操作系统、编译原理学习打基础。 二、核心基础：拆弹前必须掌握的“内功心法” 2.1 x86-64 寄存器使用惯例（重中之重） x86-64 寄存器共 16 个（%rax-%r15），按功能分为三类，必须牢记函数调用中的角色： 寄存器 功能说明 %rdi/%rsi/%rdx/%rcx/%r8/%r9 函数第 1-6 个参数（顺序严格对应，超过 6 个参数通过栈传递） %rax 函数返回值；同时是临时寄存器（调用者无需保存） %rsp 栈顶指针（Stack Pointer）：push/pop 时自动增减，指向当前栈顶 %rbp 栈底/帧指针（Base Pointer）：固定指向当前函数栈帧底部，用于定位局部变量 %rbx/%r12-%r15 被调用者保存寄存器（Callee-saved）：函数使用前必须 push 保存，退出前 pop 恢复 %r10/%r11 临时寄存器（Caller-saved）：调用者无需保存，被调用函数可随意修改 2.2 GDB 调试工具：拆弹必备“神器” 无需盲目猜测代码逻辑，用 GDB 直接查看内存、寄存器、指令执行过程，高效定位答案。 （1）基础操作：启动与反汇编 # 1. 导出完整反汇编代码 objdump -d bomb \u003e bomb.asm # 2. 启动 GDB 调试 gdb bomb （2）断点与执行控制 指令 功能说明 b phase_1 在函数 phase_1 入口打断点（直接按函数名打断点，最常用） b *0x400ee0 在内存地址 0x400ee0 打断点（函数过长时，精准定位某条指令） r（run） 运行程序，输入字符串后触发断点 ni（nexti） 单步跳过指令（不进入函数调用，如 callq strings_not_equal 直接执行完） si（stepi） 单步进入指令（进入函数内部，如查看 strings_not_equal 的执行逻辑） c（continue） 继续执行到下一个断点 q（quit） 退出 GDB （3）数据查看：核心中的核心 指令 功能说明 x/s 0x402400 以字符串（String）格式查看地址 0x402400 处的内容（Phase 1 直接用） x/d $rsp 以十进制（d）查看栈顶（%rsp 指向）的值 x/6wd $rsp 以十进制（d）查看栈顶开始的 6 个“字（4字节）”（查看数组/输入的多个整数） x/8xg 0x402470 以 8 字节（x）、十六进制（g）查看跳转表（Phase 3 用） i r（info registers） 查看所有寄存器当前值 p $rax 打印寄存器 %rax 的值（验证函数返回值、计算结果） p *(int*)0x6032d0 以 int 类型查看地址 0x6032d0 处的值（查看链表节点、结构体字段） 2.3 关键汇编指令解析：避坑指南 x86-64 汇编指令众多，重点掌握易混淆、高频出现的指令，避免因理解偏差踩坑。 （1）lea vs mov：地址 vs 数值 指令 功能说明 mov (%rdi), %rax 间接寻址：取 %rdi 指向的内存地址中的值，放入 %rax（访问内存） lea (%rdi), %rax 地址传送：将 %rdi 本身的地址值放入 %rax（不访问内存），常用于指针运算 lea (%rdi, %rdi, 2), %rax 计算 %rdi * 3（公式：基址 + 索引比例，即 x + x2 = 3x） （2）cmp vs test：条件判断的核心 指令 功能说明 cmp a, b 计算 b - a，不保存结果，仅设置标志位（ZF=0 表示不等，ZF=1 表示相等） test %eax, %eax 计算 %eax \u0026 %eax，等价于检查 %eax 是否为 0（ZF=1 则为 0） test %rdi, %rsi 计算 %rdi \u0026 %rsi，检查两个值是否有共同的置位比特 （3）跳转指令：标志位依赖 指令 依赖标志位 功能说明 je 0x400ef7 ZF=1 相等则跳转（jump equal） jne 0x400f3c ZF=0 不等则跳转（jump not equal） ja 0x400fad CF=0 且 ZF=0 无符号数大于则跳转（jump above） jle 0x400f80 CF=1 或 ZF=1 无符号数小于等于则跳转（jump less or equal） 三、逐阶段拆弹：从易到难深度解析 3.1 Phase 1：字符串比较（热身题） 核心考点：函数调用约定、字符串地址访问 汇编逐行解析 phase_1: sub $0x8,%rsp ; 栈上分配 8 字节空间（对齐栈帧） mov $0x402400,%esi ; 第 2 个参数：目标字符串地址 0x402400 存入 %esi callq 401338 \u003cstrings_not_equal\u003e ; 调用字符串比较函数，第 1 个参数（输入字符串）在 %rdi test %eax,%eax ; 检查返回值：strings_not_equal 相等返回 0，不等返回 1 je 400ef7 ; 若返回值为 0（ZF=1），跳转到安全区，炸弹不爆炸 callq 40143a \u003cexplode_bomb\u003e ; 否则触发爆炸 解法步骤 启动 GDB：gdb bomb； 打断点：b phase_1； 运行程序：r，随便输入一个字符串（如 test），触发断点； 查看目标字符串：x/s 0x402400，直接显示答案。 答案验证 输入 GDB 查看到的字符串：Border relations with Canada have never been better.，Phase 1 解除。 3.2 Phase 2：循环与栈数组（序列推导） 核心考点：栈上局部变量（数组）、循环结构、指针算术 汇编逐行解析 phase_2: sub $0x28,%rsp ; 栈上分配 40 字节（6个int数组 + 栈对齐，6*4=24，补16字节对齐） lea 0x10(%rsp),%rsi ; 第 2 个参数：数组起始地址（%rsp+16）存入 %rsi mov %rsp,%rdi ; 第 1 个参数：输入缓冲区地址存入 %rdi callq 40145c \u003cread_six_numbers\u003e ; 读取 6 个整数，存入栈上数组（%rsp+16 开始） cmpl $0x1,0x10(%rsp) ; 检查数组第 1 个元素（%rsp+16）是否为 1 jne 400f3c ; 不是 1 则爆炸 mov $0x1,%ebx ; %ebx = 1（循环变量 i=1，从第 2 个元素开始检查） mov $0x18,%rbp ; %rbp = 24（数组第 6 个元素地址：%rsp+16 + 5*4 = %rsp+36？不对，重新计算： ; 数组起始地址 %rsp+16，元素索引 0-5，地址为 %rsp+16 + i*4 ; %rbp 是循环结束边界：%rsp+16 + 6*4 = %rsp+32 = 0x20？ loop_start: mov -0x4(%rbx),%eax ; 取前一个元素：数组[i-1]（%rbx 是当前元素指针，-4 是前一个元素地址） add %eax,%eax ; 前一个元素 *2（eax = eax * 2） cmp %eax,(%rbx) ; 比较当前元素（%rbx 指向）和前一个元素*2 je loop_continue ; 相等则继续循环 callq \u003cexplode_bomb\u003e ; 不等则爆炸 loop_continue: add $0x4,%rbx ; 指针移动到下一个元素（int 占 4 字节） cmp %rbp,%rbx ; 检查是否到达循环边界 jne loop_start ; 未到则继续循环 add $0x28,%rsp ; 释放栈空间 retq ; 函数返回，Phase 2 解除 核心逻辑推导 输入要求：6 个整数（read_six_numbers 限制）； 第 1 个元素必须为 1； 从第 2 个元素开始，每个元素 = 前一个元素 × 2（等比数列）。 解法步骤 断点：b phase_2，运行 r 后输入 1 2 4 8 16 32； 验证：GDB 中用 x/6wd $rsp+16 查看栈上数组，确认每个元素符合规律； 执行 c，炸弹不爆炸，Phase 2 解除。 答案 1 2 4 8 16 32 3.3 Phase 3：Switch 跳转表（多路分支） 核心考点：switch-case 底层实现（跳转表）、多参数输入解析 汇编逐行解析 phase_3: sub $0x18,%rsp ; 栈上分配 24 字节 lea 0xc(%rsp),%rcx ; 第 3 个参数：\u0026y（第二个输入整数的地址）存入 %rcx lea 0x8(%rsp),%rdx ; 第 2 个参数：\u0026x（第一个输入整数的地址）","date":"2025-12-01","objectID":"/posts/bomblab/:0:0","tags":["CSAPP","汇编","Linux","GDB"],"title":"CSAPP Bomb Lab 详细解析与复习笔记","uri":"/posts/bomblab/"},{"categories":["学习笔记"],"content":"8086 汇编系统笔记：内存分段、栈、寻址与控制转移（超详细） 以 8086 为例，从“内存地址怎么算”一路讲到“多字节加法”“大小写转换”。 目录 8086 的内存分段与物理地址 栈（Stack）与 SS:SP 机制 内存寻址方式与 BX/BP 规则 CS:IP 与控制转移指令 JMP 标志寄存器 Flags CMP 与条件转移指令 Jxx 多字节加减法：ADC / SBB 伪指令与汇编程序骨架 例子：ASCII 字符大小写转换 Debug 观察小技巧 1. 8086 的内存分段与物理地址 1.1 分段的原因 8086 寄存器宽度为 16 位，只能直接表示 0~65535（64KB）范围的地址。 实际可访问内存是 1MB（20 位地址）。 解决方案：“段地址 × 16 + 偏移地址”。 1.2 主要段寄存器 CS：Code Segment，代码段 DS：Data Segment，数据段 SS：Stack Segment，栈段 ES：Extra Segment，附加段 通用公式： 物理地址 = 段寄存器值 × 16 + 偏移地址 常见几种场景： 访问数据： 物理地址 = DS × 16 + 偏移 访问代码： 物理地址 = CS × 16 + IP 使用 BX 做基址： 物理地址 = DS × 16 + BX + idata 使用 BP 做基址： 物理地址 = SS × 16 + BP + idata 结论：只要括号里用了 BP，默认段就是 SS；否则通常默认段是 DS。 2. 栈（Stack）与 SS:SP 机制 栈是一块专门区域，用来保存临时信息：返回地址、寄存器现场、局部变量等。 特点：后进先出（LIFO）。 2.1 栈相关寄存器 SS：栈段基址 SP：栈顶偏移地址（单位：字节） 栈顶元素的物理地址： 栈顶物理地址 = SS × 16 + SP 8086 中，栈从高地址向低地址生长。 2.2 PUSH 入栈 以 push ax 为例： SP = SP - 2 （栈顶向低地址方向移动 2 个字节） 将 AX 的 16 位内容写入到 SS:SP 处的内存 示例： mov ax, 1000H mov ss, ax mov sp, 0010H ; 初始化栈空（示例） push bx ; 第一次压栈，SP = 000EH push ax ; 第二次压栈，SP = 000CH 2.3 POP 出栈 以 pop ax 为例： 从 SS:SP 处读取 16 位数据送入 AX SP = SP + 2 （栈顶向高地址方向移动 2 个字节） 示例： pop ax ; 先把栈顶数据给 AX，SP += 2 pop bx 说明： 栈中原来的数据在内存里还存在，但逻辑上已经“无效”，下一次 push 会覆盖。 8086 不会自动检查“栈满/栈空”，越界会破坏其他数据，由程序员自己负责。 2.4 栈空间例子：10000H~1000FH 假设用 10000H ~ 1000FH 这 16 个字节作为栈区（共 16B）： 栈底最高地址：1000FH 栈空时约定：SP 指向栈底的下一单元，即 0010H 初始化代码： mov ax, 1000H mov ss, ax mov sp, 0010H ; 栈空 连续压栈时 SP 变化： SP = 0010H (空栈) push ax -\u003e SP = 000EH push bx -\u003e SP = 000CH ... 3. 内存寻址方式与 BX/BP 规则 8086 中，只有 4 个寄存器可以出现在 [...] 内参与地址计算： BX (Base) BP (Base Pointer) SI (Source Index) DI (Destination Index) 3.1 合法的组合规则 “基址”寄存器：BX 或 BP（二选一） “变址”寄存器：SI 或 DI（二选一） 可再加立即数 idata 合法示例（✅）： [bx] [bx+si] [bx+di+idata] [bp] [bp+si] [bp+di+idata] [si+idata] [di] 非法示例（❌）： [bx+bp] ; 两个基址寄存器，不允许 [si+di] ; 两个变址寄存器，不允许 [ax] ; AX 不能直接用于内存寻址 3.2 段寄存器的默认选择规则 只要地址表达式中出现了 BP，默认段寄存器 = SS 否则（使用 BX、SI、DI 等），默认段寄存器 = DS 对应的物理地址公式： mov ax, [bx+idata] ; 物理地址 = DS × 16 + BX + idata mov ax, [bp+idata] ; 物理地址 = SS × 16 + BP + idata 可以强制指定段前缀： mov ax, ds:[bp] ; 强制使用 DS 段 mov ax, ss:[bx] ; 强制使用 SS 段 3.3 DS 的常见赋值错误 段寄存器不能直接接立即数： mov ds, 1000H ; ❌ 错误 正确做法： mov ax, 1000H mov ds, ax ; ✅ 先通过通用寄存器中转 4. CS:IP 与控制转移指令 JMP 4.1 正常的取指令流程 8086 执行一条指令大致流程： 从 CS:IP 指向的内存单元取指令到指令缓冲器 IP = IP + 指令长度，指向下一条指令 执行缓冲器中的指令 只要 不修改 CS 和 IP，程序就按照内存中的顺序向前执行。 4.2 JMP 指令：修改 CS/IP jmp 的本质是：修改 CS、IP 或其中之一。 4.2.1 段内转移（只改 IP） jmp ax ; IP = AX jmp bx ; IP = BX 段寄存器 CS 不变。 也可以写成“相对跳转”的形式（编译器生成偏移量）： jmp short label jmp near label 4.2.2 段间转移（同时改 CS 和 IP） 格式： jmp 段地址:偏移 例： jmp 1000:0003 ; CS = 1000H, IP = 0003H 执行后下一条指令来自物理地址： 物理地址 = 1000H × 16 + 0003H = 10003H 5. 标志寄存器 Flags 标志寄存器并不存普通数据，而是存放各种“状态位”。 常用标志位及含义： ZF（Zero Flag）零标志：结果是否为 0 PF（Parity Flag）奇偶标志：低 8 位中 1 的个数是奇数/偶数 SF（Sign Flag）符号标志：结果最高位（符号位） CF（Carry Flag）进位标志：无符号运算中进位 / 借位 OF（Overflow Flag）溢出标志：有符号运算中是否溢出 传送类指令（mov/push/pop 等）一般不影响标志位； 算术逻辑指令（add/sub/and/or/xor/cmp 等）会影响标志位。 5.1 ZF：零标志 结果为 0 → ZF = 1 结果不为 0 → ZF = 0 在调试器中通常显示为： ZR（Zero）表示 ZF=1 NZ（Not Zero）表示 ZF=0 5.2 PF：奇偶标志 对“结果的低 8 位”统计 1 的个数： 若 1 的个数为偶数 → PF = 1（Parity Even，PE） 若 1 的个数为奇数 → PF = 0（Parity Odd，PO） 记忆：P E = Parity Even = PF=1 5.3 SF：符号标志 把结果的最高有效位复制给 SF： 最高位 = 1 → SF=1（负数） 最高位 = 0 → SF=0（非负） CPU 不关心你把数据当有符号还是无符号，它总是设置 SF。 是否使用 SF 取决于程序逻辑。 5.4 CF \u0026 OF：进位 vs 溢出 CF 下溢 / 借位（无符号减法） → CF = 1 加法最高位产生进位（无符号加法） → CF = 1 OF 针对有符号数： 正 + 正 → 得到负 → OF = 1 负 + 负 → 得到正 → OF = 1 其它情况下 OF 一般为 0 例：8 位寄存器 AL 中执行 98 + 99 mov al, 98 add al, 99 二进制： 0110 0010 (98) +0110 0011 (99) ----------- 1100 0101 (结果) 作为无符号数：范围 0~255，结果 197，没越界 → CF=0 作为有符号数：98、99 都是正数，结果最高位为 1（负数） 正 + 正 得到负数 → 溢出 → OF=1 结论：同一条指令，CF、OF 的含义取决于你是按无符号还是按有符号来解释。 6. CMP 与条件转移指令 Jxx 6.1 CMP：不留结果的 SUB cmp ax, bx 本质上等价于： 临时 = ax - bx ; 只根据这个结果更新 Flags，不把临时写回 根据结果不同，Flags 的典型变化： 若 (ax) = (bx) → 结果为 0 → ZF = 1 若 (ax) \u003c (bx)（无符号） → 借位 → CF = 1 若 (ax) \u003e (bx)（无符号） → 无借位且不为 0 → CF=0, ZF=0 6.2 常用无符号条件转移指令 以下几条通常配合 cmp 使用： je / jz：等于（ZF = 1） jne / jnz：不等于（ZF = 0） jb / jc：below / carry，小于（无符号，CF = 1） ja：above，大于（无符号，CF = 0 且 ZF = 0） jbe：below or equal，小于等于（CF = 1 或 ZF = 1） jae / jnc：above or equal，大于等于（CF","date":"2025-11-30","objectID":"/posts/017d598/:0:0","tags":["汇编语言","8086","Debug","计算机组成原理"],"title":"8086 汇编系统笔记：内存分段、栈、寻址与控制转移","uri":"/posts/017d598/"},{"categories":["学习笔记"],"content":" 8086 汇编 + Debug 调试：TRUEAD 命令与常用指令系统笔记 1. 8086 的基本“世界观” 1.1 字长与内存 字节（Byte）：8 位，范围 0~255 (00H ~ FFH) 字（Word）：16 位，由 2 个字节组成 8086 特性：16 位 CPU 寄存器宽度一般是 16 位 部分寄存器可以拆成两个 8 位使用 内存模型： 内存可以想象成一条长长的字节数组： 每个“格子”存 1 个字节 每个格子有一个 物理地址：0 ~ 1MB-1（20 位地址线） 1.2 寄存器简表 通用寄存器（16 位）： AX, BX, CX, DX 可拆分： AX = AH (高8位) + AL (低8位) BX = BH + BL CX = CH + CL DX = DH + DL 段寄存器： CS (代码段), DS (数据段), SS (栈段), ES (附加段) 指令指针： IP：记录下一条要执行的指令在代码段中的偏移量 标志寄存器 (Flags) - 重点记这几个： ZF (Zero Flag)：结果为 0 置 1 CF (Carry Flag)：无符号运算进位/借位 OF (Overflow Flag)：有符号运算溢出 SF (Sign Flag)：结果最高位（符号位） 2. 寻址公式：逻辑地址 → 物理地址 8086 不直接操作物理地址，而是使用 段地址 : 偏移地址 (Segment : Offset)。 📐 计算公式 $$\\text{物理地址} = \\text{段地址} \\times 16 + \\text{偏移地址}$$ 也就是：Physical = (Segment \u003c\u003c 4) + Offset 举例说明： 1000:0000 物理地址 = $1000H \\times 10H + 0000H$ = 10000H 1000:0009 物理地址 = $1000H \\times 10H + 0009H$ = 10009H 在 Debug 输出中的样子： 1000:0000 41 42 43 44 00 00 00 00-00 00 00 00 00 00 00 00 ABCD............ |-------| |---------------------------------------------| |--------------| 段:偏移 16个字节的十六进制数据 对应的 ASCII 字符 3. Debug 环境与进入方式 通常在 DOSBox 中运行： C:\\\u003e debug - 看到一行 - 提示符表示进入 debug 模式。 退出命令：输入 q 回车。 4. TRUEAD + GQ：Debug 常用命令总览 🔥 记忆口诀：TRUEAD + GQ 命令 全称 作用 助记 T Trace 单步执行一条指令 跟踪 R Register 显示/修改寄存器 寄存器 U Unassemble 反汇编机器码 反汇编 E Enter 修改内存数据 输入/编辑 A Assemble 汇编指令到内存 汇编 D Dump 显示内存内容 倒出(数据) G Go 连续执行程序 运行 Q Quit 退出 debug 退出 5. 命令详解 5.1 T：Trace —— 单步执行 作用：按“机器指令”为单位，一条条执行，观察寄存器、标志位变化。 语法： -t ; 从当前 CS:IP 单步执行一条 -t=1000:0000 ; 从 1000:0000 单步执行一条 常用 Debug 流程： 用 u 看某地址上的代码。 用 r 查看当前 CS:IP。 用 t 一条条执行。 每步后系统会自动显示寄存器状态，观察 AX、标志位的变化。 5.2 R：Register —— 查看/修改寄存器 作用：显示或修改 CPU 寄存器值。 语法： -r ; 显示所有寄存器及标志位 -r ax ; 显示 AX 一个寄存器（随后输入新值） -r ip 0100 ; (部分版本支持) 修改指令指针 IP 典型输出： -r AX=0000 BX=0000 CX=0000 DX=0000 SP=FFFE BP=0000 SI=0000 DI=0000 DS=0F00 ES=0F00 SS=0F00 CS=1A2B IP=0100 NV UP EI PL NZ NA PO NC 注意：最后一行大写字母是标志位状态。例如 NZ = Not Zero (ZF=0), NC = No Carry (CF=0)。 5.3 U：Unassemble —— 反汇编代码 作用：把内存中的机器码反向翻译回汇编指令。 语法： -u ; 从当前 CS:IP 开始反汇编 -u 1000:0000 ; 从 1000:0000 处反汇编 示例： 1000:0000 B8E803 MOV AX,03E8 1000:0003 B364 MOV BL,64 1000:0005 F6F3 DIV BL 5.4 E：Enter —— 修改内存数据 作用：从一个地址开始逐字节写入数据。 语法： -e 1000:0000 41 42 43 44 ; 写入十六进制 -e 1000:0000 'A' 'B' 'C' ; 写入字符常量 5.5 A：Assemble —— 汇编指令到内存 作用：直接输入汇编助记符，Debug 自动将其转为机器码。 语法： -a 1000:0000 1000:0000 mov ax, 1000 1000:0003 mov bl, 60 1000:0005 div bl 1000:0007 int 3 ; 常用 int 3 作为断点 1000:0008 \u003c回车结束\u003e 5.6 D：Dump —— 查看内存内容 作用：以“十六进制 + ASCII”的形式显示内存。 语法： -d ; 从当前 DS:offset 开始 -d 1000:0000 ; 从 1000:0000 显示一屏 5.7 G：Go —— 连续执行程序 作用：全速运行，直到程序结束或遇到断点（如 INT 3）。 语法： -g ; 从当前 CS:IP 跑 -g=1000:0000 ; 设定入口地址并运行 6. 核心指令与标志位实战 6.1 ADD \u0026 SUB：加减法 示例 1：ADD 无溢出 mov al, 0F0h ; AL = 240 add al, 0Ah ; AL = 240 + 10 = 250 (FAH) ; 结果：CF=0, ZF=0 示例 2：ADD 产生进位 (CF=1) mov al, 0F0h ; 240 add al, 20h ; 240 + 32 = 272 (\u003e255) ; 结果：AL=10H (溢出部分丢弃), CF=1 示例 3：SUB 产生借位 (CF=1) mov al, 20h ; 32 sub al, 30h ; 32 - 48 ; 结果：AL=F0H, CF=1 (不够减，借位) 6.2 DIV：无符号除法 DIV 指令根据除数的位数（8位或16位）有不同的行为： 除数位数 被除数位置 商存储位置 余数存储位置 8 位 (reg/mem8) AX (16位) AL AH 16 位 (reg/mem16) DX:AX (32位) AX DX ⚠️ 注意：DX:AX 表示高 16 位存 DX，低 16 位存 AX。 典型实验案例： 8 位除法（整除） mov ax, 1000 ; 03E8H mov bl, 100 ; 64H div bl ; 1000 / 100 ; 结果：AL = 0Ah (10), AH = 00h (0) 8 位除法（有余数） mov ax, 1000 mov bl, 60 div bl ; 结果：AL = 10H (16), AH = 28H (40) 除法溢出 (Divide Error) 如果商超过了寄存器能表示的范围（例如 8 位除法商 \u003e 255），Debug 会报错 Divide error。 7. 综合实验模板 模板一：除法实验 (A + G + R) -a 1000:0 mov ax, 1000 mov bl, 60 div bl int 3 -g=1000:0 -r ; 检查 AX 结果 模板二：内存读写实验 (D + E) -d 1000:0 ; 查看原始内容 -e 1000:0 'A' 'B' 'C' -d 1000:0 ; 验证修改结果 模板三：单步跟踪 (A + T) -a 1000:0 mov al, F0 add al, 20 int 3 -r ; 看初始状态 -t=1000:0 ; 执行第一句 -r ; 检查 -t ; 执行第二句 -r ; 检查 CF 标志位 8. 总结 地址计算：物理地址 = $段 \\times 16 + 偏移$。 七大命令：T(跟踪), R(寄存器), U(反汇编), E(改内存), A(写汇编), D(看内存), G(运行)。 DIV 规则： 除数 8 位 → 结果在 AX (商AL, 余AH) 除数 16 位 → 结果在 AX, DX (商AX, 余DX) 标志位：重点关注 CF (进位/借位) 和 ZF (零标志)。 ","date":"2025-11-25","objectID":"/posts/017d598/:0:0","tags":["汇编语言","8086","Debug","计算机组成原理"],"title":"8086 汇编 + Debug 调试：TRUEAD 命令与常用指令系统笔记","uri":"/posts/017d598/"},{"categories":["学习笔记"],"content":"Java 笔记3.0 八、常用类与集合框架：Java 开发的“工具箱”（续） 二、集合框架：Java 存储数据的“容器”（续） 3. List 接口：有序可重复集合 List 接口的核心是“有序、可重复、支持索引访问”，常用实现类为 ArrayList 和 LinkedList，两者底层结构不同，导致性能差异显著。 （1）ArrayList：动态数组实现（查询优先） 底层结构：基于动态数组（JDK 8 无初始容量时默认空数组，第一次添加元素时扩容为 10；JDK 7 初始容量默认 10），数组满时自动扩容（扩容机制：JDK 8 及后为原容量的 1.5 倍，JDK 7 为 1.5 倍+1）。 核心特点： 优势：支持通过索引（get(int index)）直接访问元素，查询效率高（时间复杂度 O(1)）； 劣势：增删元素时需移动数组元素（如在中间插入元素，需后移后续所有元素），增删效率低（时间复杂度 O(n)）； 线程安全：线程不安全（多线程并发修改可能抛出 ConcurrentModificationException）。 常用方法（除 Collection 通用方法外）： E get(int index)：通过索引获取元素； E set(int index, E element)：替换指定索引的元素； void add(int index, E element)：在指定索引插入元素； E remove(int index)：删除指定索引的元素； int indexOf(Object o)：返回元素首次出现的索引（无则返回 -1）。 代码示例（ArrayList 用法） import java.util.ArrayList; import java.util.List; public class ArrayListDemo { public static void main(String[] args) { // 1. 创建 ArrayList 集合（泛型指定存储 String 类型） List\u003cString\u003e list = new ArrayList\u003c\u003e(); // 2. 添加元素 list.add(\"Java\"); list.add(\"Python\"); list.add(\"C++\"); System.out.println(\"初始集合：\" + list); // 输出：[Java, Python, C++] // 3. 索引访问 String first = list.get(0); System.out.println(\"索引 0 的元素：\" + first); // 输出：Java // 4. 插入元素（索引 1 位置） list.add(1, \"Go\"); System.out.println(\"插入后集合：\" + list); // 输出：[Java, Go, Python, C++] // 5. 修改元素（索引 2 位置） list.set(2, \"JavaScript\"); System.out.println(\"修改后集合：\" + list); // 输出：[Java, Go, JavaScript, C++] // 6. 删除元素（索引 3 位置） list.remove(3); System.out.println(\"删除后集合：\" + list); // 输出：[Java, Go, JavaScript] // 7. 遍历集合（三种方式） // 方式 1：普通 for 循环（利用索引） System.out.println(\"普通 for 循环遍历：\"); for (int i = 0; i \u003c list.size(); i++) { System.out.print(list.get(i) + \" \"); // 输出：Java Go JavaScript } // 方式 2：增强 for 循环（foreach） System.out.println(\"\\n增强 for 循环遍历：\"); for (String lang : list) { System.out.print(lang + \" \"); } // 方式 3：迭代器（Iterator） System.out.println(\"\\n迭代器遍历：\"); java.util.Iterator\u003cString\u003e it = list.iterator(); while (it.hasNext()) { // 判断是否有下一个元素 String lang = it.next(); // 获取下一个元素 System.out.print(lang + \" \"); } } } （2）LinkedList：双向链表实现（增删优先） 底层结构：基于双向链表（每个节点包含 prev（前驱）、element（元素）、next（后继）），无需连续内存空间。 核心特点： 优势：增删元素时只需修改链表节点的 prev 和 next 指针，增删效率高（尤其是首尾操作，时间复杂度 O(1)）； 劣势：查询元素需从链表头/尾遍历，查询效率低（时间复杂度 O(n)）； 线程安全：线程不安全； 额外功能：实现 Deque 接口，可作为队列（FIFO）或栈（LIFO）使用。 常用方法（除 List 通用方法外，新增首尾操作）： void addFirst(E e)：在链表头部添加元素； void addLast(E e)：在链表尾部添加元素（等同于 add(E e)）； E getFirst()：获取头部元素； E getLast()：获取尾部元素； E removeFirst()：删除头部元素； E removeLast()：删除尾部元素。 代码示例（LinkedList 作为队列和栈） import java.util.LinkedList; import java.util.Queue; import java.util.Deque; public class LinkedListDemo { public static void main(String[] args) { // 1. 作为队列（先进先出，FIFO） Queue\u003cString\u003e queue = new LinkedList\u003c\u003e(); queue.offer(\"A\"); // 入队（尾部添加） queue.offer(\"B\"); queue.offer(\"C\"); System.out.println(\"队列初始：\" + queue); // 输出：[A, B, C] String pollElem = queue.poll(); // 出队（头部删除） System.out.println(\"出队元素：\" + pollElem); // 输出：A System.out.println(\"出队后队列：\" + queue); // 输出：[B, C] // 2. 作为栈（先进后出，LIFO） Deque\u003cString\u003e stack = new LinkedList\u003c\u003e(); stack.push(\"X\"); // 入栈（头部添加） stack.push(\"Y\"); stack.push(\"Z\"); System.out.println(\"栈初始：\" + stack); // 输出：[Z, Y, X] String popElem = stack.pop(); // 出栈（头部删除） System.out.println(\"出栈元素：\" + popElem); // 输出：Z System.out.println(\"出栈后栈：\" + stack); // 输出：[Y, X] } } （3）ArrayList vs LinkedList 对比选择 对比维度 ArrayList LinkedList 底层结构 动态数组 双向链表 查询效率 高（O(1)，索引访问） 低（O(n)，遍历访问） 增删效率 低（O(n)，移动元素） 高（O(1)，首尾操作；O(n)，中间操作） 内存占用 可能有冗余（数组扩容预留空间） 无冗余（节点按需创建） 适用场景 频繁查询、少量增删（如数据展示） 频繁增删、少量查询（如队列/栈） 4. Set 接口：无序不可重复集合 Set 接口的核心是“无序（存储顺序与添加顺序无关）、不可重复（元素唯一）、无索引”，常用实现类为 HashSet、LinkedHashSet、TreeSet。 （1）HashSet：哈希表实现（无序去重） 底层结构：JDK 8 前为“数组+链表”，JDK 8 及后为“数组+链表/红黑树”（当链表长度超过 8 且数组容量≥64 时，链表转为红黑树，提升查询效率）。 去重原理：基于 hashCode() 和 equals() 方法，核心逻辑： 新增元素时，先调用元素的 hashCode() 方法，计算哈希值，确定在数组中的存储位置； 若该位置为空，直接存入元素； 若该位置不为空，调用该位置已有元素的 equals() 方法与新增元素比较： 若 equals() 返回 true，视为重复元素，不存入； 若 equals() 返回 false，存入链表（或红黑树）。 重要约定：若重写 equals() 方法，必须同时重写 hashCode() 方法，确保“相等的对象必须有相等的哈希值”（否则会导致 HashSet 无法去重）。 核心特点：无序、不可重复、查询效率高（平均 O(1)）、线程不安全。 代码示例（HashSet 去重与重写方法） import java.util.HashSet; import ","date":"2025-11-17","objectID":"/posts/86f3bbb/:0:0","tags":null,"title":"Java笔记3.0","uri":"/posts/86f3bbb/"},{"categories":["学习笔记"],"content":"Java 笔记2.0 一、super 与 this 关键字：对象与父类的“桥梁” 1. 核心本质与作用 this：代表当前对象实例的引用，本质是“指向当前正在执行方法的对象”，用于访问本类的属性、方法、构造器。 super：代表父类对象的引用（非父类实例，而是子类对象中父类的“部分”），用于访问父类的属性、方法、构造器，仅存在于继承场景。 2. 构造方法中的使用（重点） （1）调用规则 无论是 this()（调用本类构造）还是 super()（调用父类构造），必须放在构造方法的第一行（否则编译报错）。 super() 和 this() 不能同时出现（因为第一行只能有一个，且两者都需占第一行）。 若子类构造中未显式调用 super()，编译器会默认添加 super()（调用父类无参构造），若父类无无参构造，则必须显式调用父类有参构造。 （2）代码示例 // 父类 class Father { private String name; // 父类无参构造 public Father() { System.out.println(\"Father 无参构造执行\"); } // 父类有参构造 public Father(String name) { this.name = name; System.out.println(\"Father 有参构造执行，name=\" + name); } } // 子类 class Son extends Father { private int age; // 子类无参构造 public Son() { // 编译器默认添加 super()，调用父类无参构造 System.out.println(\"Son 无参构造执行\"); } // 子类有参构造 public Son(String fatherName, int age) { super(fatherName); // 显式调用父类有参构造（必须在第一行） this.age = age; // this 访问本类属性 System.out.println(\"Son 有参构造执行，age=\" + age); } // this 调用本类其他构造 public Son(int age) { this(\"张三\", age); // 调用本类的 Son(String, int) 构造（必须在第一行） } } // 测试 public class Test { public static void main(String[] args) { Son son1 = new Son(); // 输出：Father 无参构造执行 → Son 无参构造执行 Son son2 = new Son(\"李四\", 18); // 输出：Father 有参构造执行，name=李四 → Son 有参构造执行，age=18 } } 3. 访问属性与方法的用法 场景 语法示例 说明 访问本类属性 this.属性名 若局部变量与属性重名，必须用 this 区分 访问父类属性 super.属性名 需保证父类属性访问权限（非 private） 调用本类方法 this.方法名(参数) 可省略 this（无歧义时） 调用父类方法 super.方法名(参数) 用于调用父类未被重写的方法 代码示例 class Father { protected String familyName = \"张\"; // 父类受保护属性 public void sayFamily() { System.out.println(\"家族姓氏：\" + familyName); } } class Son extends Father { private String familyName = \"李\"; // 子类与父类属性重名（隐藏父类属性） @Override public void sayFamily() { System.out.println(\"子类姓氏：\" + this.familyName); // 访问子类属性 System.out.println(\"父类姓氏：\" + super.familyName); // 访问父类属性 super.sayFamily(); // 调用父类方法 } } public class Test { public static void main(String[] args) { Son son = new Son(); son.sayFamily(); // 输出： // 子类姓氏：李 // 父类姓氏：张 // 家族姓氏：张 } } 4. 核心区别对比 对比维度 this super 代表对象 当前对象实例 父类对象的引用（子类中的父类部分） 使用前提 无继承也可使用（只要是对象） 必须存在继承关系 访问构造器 this()：调用本类构造 super()：调用父类构造 访问属性/方法 优先访问本类，无则向上找 直接访问父类 与构造器的关系 可调用本类其他构造，需在第一行 可调用父类构造，需在第一行 5. 易错点总结 super() 必须在构造第一行：若放在后面，编译直接报错（Java 语法强制）。 父类无无参构造时，子类必须显式调用父类有参构造：否则编译器默认添加的 super() 会找不到父类无参构造，报 NoSuchMethodError。 this 不能在静态方法中使用：静态方法属于类，无对象实例，而 this 依赖对象；super 同理，也不能在静态方法中使用。 二、静态（static）与非静态成员：类与对象的“边界” 1. 核心概念与内存模型 静态成员（static 修饰）：包括静态属性、静态方法，属于类本身，存储在 方法区的静态区，仅加载一次（类加载时初始化），所有对象共享。 非静态成员：包括非静态属性、非静态方法，属于对象实例，存储在 堆内存，每个对象有独立副本，需创建对象后访问。 2. 静态成员的特性与用法 （1）静态属性（类变量） 初始化时机：类加载时（早于对象创建），默认值与非静态属性一致（如 int 为 0，String 为 null）。 访问方式：类名.静态属性名（推荐）或 对象.静态属性名（不推荐，易混淆）。 应用场景：存储共享数据（如计数器、常量）。 （2）静态方法（类方法） 访问限制：不能直接访问非静态成员（非静态成员依赖对象，静态方法无对象），但可访问静态成员；不能使用 this/super。 访问方式：类名.静态方法名(参数)（推荐）或 对象.静态方法名(参数)。 应用场景：工具类方法（如 Math.random()、Arrays.sort()）、无状态方法（不依赖对象属性）。 代码示例 class Tool { // 静态属性（共享计数器） public static int count = 0; // 静态方法（工具方法） public static int add(int a, int b) { count++; // 静态方法访问静态属性 return a + b; } // 非静态方法 public void showCount() { System.out.println(\"调用次数：\" + count); // 非静态方法可访问静态属性 } } public class Test { public static void main(String[] args) { // 静态方法直接通过类名调用 int sum1 = Tool.add(1, 2); int sum2 = Tool.add(3, 4); // 静态属性通过类名访问 System.out.println(\"静态属性 count：\" + Tool.count); // 输出 2 // 非静态方法需创建对象调用 Tool tool = new Tool(); tool.showCount(); // 输出 调用次数：2 } } 3. 静态 vs 非静态：关键区别 对比维度 静态成员（static） 非静态成员 所属对象 类本身 对象实例 内存位置 方法区静态区 堆内存 加载时机 类加载时 对象创建时 访问方式 类名.成员（推荐） 对象.成员（必须） 访问权限 不能访问非静态成员 可访问静态/非静态成员 this/super 不能使用 可以使用 共享性 所有对象共享 每个对象独立 4. 静态方法与多态的关系（重点易错点） 静态方法不参与多态：方法调用时，编译器根据“引用的类型”（而非对象实际类型）确定调用的方法，即“静态绑定”（编译时确定）。 代码示例（结合继承） class Father { public static void test() { System.out.println(\"Father 静态 test()\"); } } class Son extends Father { public static void test() { System.out.println(\"Son 静态 test()\"); } } public class Test { public static void main(String[] args) { Father f1 = new Father(); Father f2 = new Son(); // 父类引用指向子类对象 Son s1 = new Son(); f1.test(); // 输出 Father 静态 test()（引用类型是 Father） f2.test(); // 输出 Father 静态 test()（引用类型是 Father，不","date":"2025-11-17","objectID":"/posts/54c6db0/:0:0","tags":null,"title":"Java笔记2.0","uri":"/posts/54c6db0/"},{"categories":null,"content":"Javase基础笔记1.0——基于《狂神说Java》 1. 人机交互第一步：Scanner类（Java5新特性） 1.1 核心定位：解决“程序没人交互”的痛点 在学Scanner之前，我们写的程序都是“自说自话”（比如固定打印Hello World），而java.util.Scanner是Java提供的原生输入工具，能获取用户从控制台输入的文本、数字等内容。 1.2 完整使用流程（含资源关闭） Scanner的使用分5步，缺一不可（尤其是关闭资源，避免内存泄漏）： import java.util.Scanner; // 1. 导入Scanner包（IDEA会自动提示） public class ScannerDemo { public static void main(String[] args) { // 2. 创建Scanner对象，关联系统输入流（System.in = 控制台输入） Scanner scanner = new Scanner(System.in); // 3. 判断是否有输入（避免读取空数据抛异常） System.out.print(\"请输入你的姓名：\"); if (scanner.hasNextLine()) { // 判断是否有完整行输入 // 4. 读取输入内容 String name = scanner.nextLine(); System.out.println(\"你好，\" + name + \"！\"); } // 5. 关闭Scanner，释放输入流资源（必须做！） scanner.close(); } } 运行效果： 请输入你的姓名：张三 你好，张三！ 1.3 关键方法：判断与读取的“黄金搭档” Scanner的核心是“先判断，再读取”，避免直接读取导致的InputMismatchException（输入类型不匹配）。以下是常用方法对比： 方法类别 方法名 功能描述 适用场景 判断输入 hasNext() 判断后续是否有“有效字符”（非空格/Tab/Enter），返回boolean 读取不含空格的字符串 判断输入 hasNextLine() 判断后续是否有“完整行”（以Enter为结束符），返回boolean 读取含空格的字符串（如姓名） 判断输入 hasNextInt() 判断后续输入是否为整数，返回boolean 读取年龄、分数等int类型数据 判断输入 hasNextDouble() 判断后续输入是否为浮点数，返回boolean 读取工资、身高等double数据 读取输入 next() 读取“有效字符到空白字符”的字符串（不含空白） 读取用户名（无空格） 读取输入 nextLine() 读取“当前位置到Enter前”的所有字符（含空白） 读取地址、备注（含空格） 读取输入 nextInt() 读取整数并返回int，输入非整数会抛异常 读取整数 读取输入 nextDouble() 读取浮点数并返回double，输入非浮点数会抛异常 读取浮点数 1.4 深坑预警：next()与nextLine()的“兼容性问题” 这是入门最容易踩的坑！当next()和nextLine()连续使用时，nextLine()会“吃掉”next()残留的Enter，导致读取空字符串。 问题复现： Scanner scanner = new Scanner(System.in); System.out.print(\"请输入年龄：\"); int age = scanner.nextInt(); // 输入“25”后按Enter，缓冲区残留Enter System.out.print(\"请输入姓名：\"); String name = scanner.nextLine(); // 直接读取残留的Enter，返回空字符串 System.out.println(\"年龄：\" + age + \"，姓名：\" + name); // 姓名为空 运行效果： 请输入年龄：25 请输入姓名： 年龄：25，姓名： 解决方案（两种）： 方案1：额外调用nextLine()消耗Enter 在nextInt()后加一行scanner.nextLine();，手动清空缓冲区： int age = scanner.nextInt(); scanner.nextLine(); // 关键：消耗残留的Enter String name = scanner.nextLine(); // 正常读取姓名 方案2：统一用nextLine()读取，再手动转类型 避免混合使用不同读取方法，先读字符串再转成目标类型（更推荐，通用性强）： System.out.print(\"请输入年龄：\"); String ageStr = scanner.nextLine(); // 先读字符串 int age = Integer.parseInt(ageStr); // 转成int System.out.print(\"请输入姓名：\"); String name = scanner.nextLine(); // 正常读取 2. 方法进阶：可变参数——解决“参数数量不确定” 2.1 核心场景：当方法参数“可多可少”时 比如实现“求任意个数字的最大值”，如果没有可变参数，需要重载多个方法（max(int a)、max(int a,int b)、max(int a,int b,int c)），麻烦且不灵活。 JDK1.5引入的可变参数，允许方法接收“数量不固定的同类型参数”，本质是数组的语法糖（底层仍用数组存储）。 2.2 语法规则：3个“必须遵守” 声明格式：在参数类型后加省略号（...），参数名自定义（如numbers）； 数量限制：一个方法只能有1个可变参数（多了会歧义）； 位置限制：可变参数必须是方法的最后一个参数（普通参数需在前面）。 错误与正确示例对比： 语法示例 是否正确 原因分析 public static void printMax(double... numbers) ✅ 符合“类型+…+参数名”，无其他参数 public static void test(String name, int... scores) ✅ 可变参数在最后，普通参数在前面 public static void test(int... scores, String name) ❌ 可变参数不是最后一个参数 public static void test(int... a, double... b) ❌ 一个方法有2个可变参数，无法区分参数边界 2.3 实战案例：求任意个double数字的最大值 public class VariableArgsDemo { public static void main(String[] args) { // 调用可变参数方法：可传0个、1个、多个参数，或直接传数组 printMax(); // 无参数 printMax(1.5); // 1个参数 printMax(3.2, 5.8, 2.9, 4.1); // 多个参数 printMax(new double[]{1.1, 2.2, 3.3}); // 传数组（底层兼容） } // 可变参数方法：求最大值 public static void printMax(double... numbers) { // 1. 判断是否传入参数（numbers本质是数组，length=0表示无参数） if (numbers.length == 0) { System.out.println(\"⚠️ 未传入任何参数\"); return; // 结束方法，避免后续空指针 } // 2. 初始化最大值（取第一个参数） double max = numbers[0]; // 3. 遍历数组，对比更新最大值（原笔记标注“排序!”，遍历更高效） for (double num : numbers) { if (num \u003e max) { max = num; } } // 4. 输出结果 System.out.println(\"当前最大值：\" + max); } } 运行效果： ⚠️ 未传入任何参数 当前最大值：1.5 当前最大值：5.8 当前最大值：3.3 3. 底层核心：Java内存分析——搞懂“对象存在哪里” 这是Java的“灵魂知识点”，很多人学完面向对象还不清楚“new的对象存在哪”“引用变量是什么”。结合原笔记的ProcessOn配图，我们用Pet类实例拆解堆、栈、方法区的分工。 3.1 内存三分区：职责分明 Java内存主要分为堆（Heap）、栈（Stack）、方法区（Method Area，JDK8+为元空间），各分区存储内容和特性完全不同： 分区名称 存储内容（超详细版） 线程共享性 生命周期 堆（Heap） 1. 所有new创建的对象（如new Pet()、new Person()）； 2. 所有数组（如new int[5]）； 3. 对象的成员变量（随对象存储，有默认值） 可被所有线程共享 随对象创建而分配，随GC（垃圾回收）回收而释放（无需手动管理） 栈（Stack） 1. 基本类型变量（如int age=25，存储“25”这个具体数值）； 2. 引用类型变量（如Pet cat=new Pet()，存储“对象在堆中的地址”）； 3. 方法调用的栈帧（存储局部变量、操作数栈、返回地址） 线程私有（每个线程独立栈） 栈帧随方法调用创建，方法执行完出栈；变量随作用域（如代码块）结束而释放 方法区（Method Area） 1. 类的字节码信","date":"2025-11-11","objectID":"/posts/java%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"Javase","uri":"/posts/java%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"DataLab 位运算实验详解 实验概述 实验目的： 熟悉和掌握计算机中整数和浮点数的二进制编码表示 实验环境： C语言编程环境 实验时间： 2025年10月23日 实验内容详解 第1关：bitAnd - 位与运算 知识点 德摩根定律： x \u0026 y = ~(~x | ~y) 位运算基础： 取反、或运算的应用 任务要求 补充函数bitAnd()，只用~，|实现x \u0026 y 操作符限制： ~，| 操作符数量限制： 8 解题思路 根据德摩根定律，位与运算可以通过取反和或运算来实现： 对x和y分别进行取反操作：~x，~y 对两个结果进行按位或运算：~x | ~y 对最终结果再次取反：~(~x | ~y) 代码实现 int bitAnd(int x, int y) { return ~(~x | ~y); } 第2关：getByte - 字节提取 知识点 字节编号： 从低位到高位从0开始编号 位偏移计算： 每个字节占8位，n号字节对应8n位偏移 掩码操作： 使用\u0026 0xFF提取最低8位 任务要求 补充函数getByte()，取出x中的n号字节 字节编号： 从低位到高位从0开始 操作符数量限制： 6 解题思路 计算位偏移量：n \u003c\u003c 3（相当于n * 8） 将x右移相应位数：x \u003e\u003e (n \u003c\u003c 3) 使用掩码0xFF提取最低8位：\u0026 0xFF 代码实现 int getByte(int x, int n) { return (x \u003e\u003e (n \u003c\u003c 3)) \u0026 0xFF; } 示例分析 对于x = 0x12345678： 字节3：0x12（最高位字节） 字节2：0x34 字节1：0x56 字节0：0x78（最低位字节） 提取字节1：n \u003c\u003c 3 = 8，x \u003e\u003e 8 = 0x00123456，\u0026 0xFF = 0x56 第3关：logicalShift - 逻辑右移 知识点 逻辑右移： 高位补0 算术右移： 高位补符号位 掩码构造： 生成合适的掩码来清除符号位扩展 任务要求 补充函数logicalShift()，将x逻辑右移n位（0 ≤ n ≤ 31） 操作符数量限制： 20 解题思路 生成基准高位标志：1 \u003c\u003c 31（仅最高位为1） 对标志进行算术右移n位：(1 \u003c\u003c 31) \u003e\u003e n 取反得到掩码：~((1 \u003c\u003c 31) \u003e\u003e n) 对x进行算术右移后与掩码结合：(x \u003e\u003e n) \u0026 mask 代码实现 int m=1 \u003c\u003c 31; m=~((m \u003e\u003e n) \u003c\u003c 1); return (x \u003e\u003e n)\u0026 m; 第4关：bitCount - 位计数 知识点 位统计： 统计二进制表示中1的个数 位掩码： 使用左移操作生成位掩码 循环思想： 通过重复操作实现循环效果 任务要求 补充函数bitCount()，统计x的二进制表示中1的数量 解题思路 使用暴力方法，遍历每一位并统计1的个数： 初始化计数器为0 对于每一位i（0-31）： 生成位掩码：1 \u003c\u003c i 与x进行与运算：x \u0026 (1 \u003c\u003c i) 如果结果非0，计数器加1 代码实现 int ret = 0; for(int i=0; i\u003c32; i++){ if(x \u0026 (1\u003c\u003ci)){ ret++; } } return ret; 第5关：bang - 逻辑非运算 知识点 逻辑非特性： !x在x为0时返回1，x非0时返回0 补码特性： x和-x的符号位相反 符号位提取： 通过右移31位提取符号位 任务要求 补充函数bang()，实现逻辑非运算!x 操作符限制： ~ \u0026 ^ | + \u003c\u003c \u003e\u003e 操作符数量限制： 12 解题思路 利用补码特性：x | (-x) 当x = 0时，结果为0 当x ≠ 0时，结果的最高位为1 提取符号位：(x | (-x)) \u003e\u003e 31 调整结果：加1得到最终的逻辑非结果 代码实现 int bang(int x) { return ((x | (~x + 1)) \u003e\u003e 31) + 1; } 详细分析 x = 0： 0 | 0 = 0，0 \u003e\u003e 31 = 0，0 + 1 = 1 → 正确 x ≠ 0： x | (-x)最高位为1，\u003e\u003e 31得到-1，-1 + 1 = 0 → 正确 第6关：tmin - 最小补码整数 知识点 补码表示： 32位补码的最小值为-2^31 位操作： 通过左移操作生成最小值 任务要求 补充函数tmin()，返回补码表示的整型最小值 操作符数量限制： 4 解题思路 32位补码的最小值是-2^31，其二进制表示为最高位1，其余位0。通过1 \u003c\u003c 31可以直接生成这个值。 代码实现 int tmin(void) { return 1 \u003c\u003c 31; } 第7关：fitsBits - 位数适配检查 知识点 补码范围： n位补码的范围是[-2^(n-1), 2^(n-1)-1] 符号扩展： 左移再右移可以检验是否在范围内 任务要求 补充函数fitsBits()，如果x可以只用n位补码表示则返回1，否则返回0（1 ≤ n ≤ 32） 操作符数量限制： 15 解题思路 计算移位量：32 - n 左移后再右移：(x \u003c\u003c (32 - n)) \u003e\u003e (32 - n) 比较结果与原x是否相等：相等则在范围内 代码实现 int fitsBits(int x, int n) { return x == ((x \u003c\u003c (32 - n)) \u003e\u003e (32 - n)); } 第8关：divpwr2 - 除以2的幂 知识点 向零舍入： 正数向下舍入，负数向上舍入 偏移量修正： 负数需要添加偏移量来实现向零舍入 任务要求 补充函数divpwr2()，计算x / 2^n，结果向零取整（0 ≤ n ≤ 30） 操作符数量限制： 15 解题思路 生成偏移量：(1 \u003c\u003c n) - 1 提取符号位：x \u003e\u003e 31 计算修正值：(x \u003e\u003e 31) \u0026 ((1 \u003c\u003c n) - 1) 加偏移量后右移：(x + bias) \u003e\u003e n 代码实现 int divpwr2(int x, int n) { int bias = (x \u003e\u003e 31) \u0026 ((1 \u003c\u003c n) - 1); return (x + bias) \u003e\u003e n; } 第9关：negate - 取负数 知识点 补码取负： 补码的负数等于取反加1 位运算实现： ~x + 1 任务要求 补充函数negate()，计算-x 解题思路 根据补码的特性，一个数的负数等于它的取反加1：-x = ~x + 1 代码实现 int negate(int x) { return ~x + 1; } 第10关：isPositive - 正数判断 知识点 符号位检查： 最高位为0表示正数 非零检查： 需要排除x = 0的情况 任务要求 补充函数isPositive()，如果x大于0返回1，否则返回0 操作符数量限制： 8 解题思路 检查符号位：(x \u003e\u003e 31) \u0026 1 → 0表示非负 检查是否非零：!!x → 1表示非零 两者结合：(!((x \u003e\u003e 31) \u0026 1)) \u0026 (!!x) 代码实现 int isPositive(int x) { return !((x \u003e\u003e 31) \u0026 1) \u0026 (!!x); } 第11关：isLessOrEqual - 小于等于判断 知识点 符号比较： 不同符号的数比较 差值比较： 相同符号的数通过差值比较 任务要求 补充函数isLessOrEqual()，如果x小于等于y则返回1 操作符数量限制： 24 解题思路 符号不同： x负y正 → x ≤ y → 返回1 x正y负 → x \u003e y → 返回0 符号相同： 计算y - x 检查y - x的符号位 代码实现 int x1=x\u003e\u003e31; int y1=y\u003e\u003e31; int case1=x1\u0026!y1;//x负y正的情况 int temp=y+~x+1; //y-x int case2=(!(temp\u003e\u003e31))\u0026(!(x1^y1));//xy同号但是y-x大于0 return case1|case2; 第12关：ilog2 - 以2为底的对数 知识点 二进制最高位： 找到最高位1的位置 二分查找： 通过二分法快速定位最高位 任务要求 补充函数ilog2()，返回x以2为底的对数的整数部分 解题思路 使用二分法定位最高位1的位置： 检查高16位是否有1 检查高8位是否有1 继续检查4位、2位、1位 就是不断逼近逼近 代码实现 int ret = 0; if (x \u003e= (1 \u003c\u003c 16)) { ret += 16; x \u003e\u003e= 16; } if (x \u003e= (1 \u003c\u003c 8)) { ret += 8; x \u003e\u003e= 8; } if (x \u003e= (1 \u003c\u003c 4)) { ret += 4; x \u003e\u003e= 4; } if (x \u003e= (1 \u003c\u003c 2)) { ret += 2; x \u003e\u003e= 2; } if (x \u003e= (1 \u003c\u003c 1)) { ret += 1; x \u003e\u003e= 1; } return ret; 第13关：float_neg - 浮点数取负 知识点 IEEE 754浮点数： 符号位、阶码、尾数三部分组成 符号位操作： 取反符号位即可得到负数 任务要求 补充函数float_neg()，返回-f的位级表示 解题思路 提取符号位：uf \u003e\u003e 31 取反符号位：1 ^ (uf \u003e\u003e 31) 重组浮点数：(new_sign \u003c\u003c 31) | (uf \u0026 0x7FFFFFFF) 代码实现 unsigned int jieshu=(uf\u003e\u003e23)\u00260xFF; unsigned int weishu=uf\u00260x7FFFFF","date":"2025-10-29","objectID":"/posts/datalab%E8%AF%A6%E8%A7%A3/:0:0","tags":null,"title":"DataLab详解","uri":"/posts/datalab%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"javaseexp-02 首先得有花色和牌面吧，这俩都是固定的，所以用了枚举。花色就叫Suit，放了黑桃、红桃、梅花、方块；牌面是Face，从二到A，每个牌面还带了个value，比如A是14，这样后面比大小方便。代码大概是这样的： public enum Face { 二(2), 三(3), ..., A(14); // 中间省略了其他牌面 private int value; Face(int value) { this.value = value; } public int getValue() { return value; } } 然后是单张牌，用Card类来表示，里面就俩属性：suit（花色）和face（牌面）。构造方法传这俩参数，还得有getter方法拿属性。最开始写toString的时候直接用suit + face，结果打印出来不对，后来才知道枚举得用name()方法，改成suit.name() + face.name()就正常了，能显示“红桃七”这种格式。 public class Card { private Suit suit; private Face face; public Card(Suit suit, Face face) { this.suit = suit; this.face = face; } // getter方法省略 public String toString() { return suit.name() + face.name(); // 这里踩过坑，刚开始没加name() } } 牌组的话，写了个Poke类，负责生成牌。构造方法里用嵌套循环，外层控制几副牌，中间循环花色，内层循环牌面，每次循环就new一个Card加进列表里。这样不管要1副还是2副，传个参数就行。 发牌和洗牌的功能，有Action接口，定义了shuffle、distribute、display这几个方法，然后让Game类去实现。洗牌简单，用Collections.shuffle直接打乱列表就行。发牌的时候卡了一下，怎么让牌轮流分给每个玩家呢？后来想到用取余，index是当前牌的序号，index % player就能得到该发给第几个玩家，比如3个玩家的话，0%3=0（玩家1），1%3=1（玩家2），2%3=2（玩家3），3%3=0（又回到玩家1），代码是这样的： public void distribute(ArrayList\u003cCard\u003e cards, ArrayList\u003cArrayList\u003cCard\u003e\u003e playercards, int player) { int index = 0; for (Card card : cards) { playercards.get(index % player).add(card); // 取余实现轮流发牌 index++; } } 不过刚开始运行的时候报了空指针异常，调试了半天才发现，playercards里的每个玩家列表没初始化，只是new了个外层列表，里面的小列表还是null。后来在main里加了循环，给每个玩家new一个ArrayList，就好了： // 初始化玩家手牌列表，这里刚开始漏掉了，导致空指针 for (int i = 0; i \u003c players; i++) { playercards.add(new ArrayList\u003c\u003e()); } 比大小的时候，直接拿两张牌的face.getValue()比较就行，这个逻辑简单，没出什么问题。 整个流程就是：让用户输入几副牌、几个玩家，然后生成牌组、洗牌、发牌，最后显示每个玩家的牌，再随机抽两张比大小。运行起来还挺顺畅的，就是写的时候有些细节没注意，踩了几个小坑，调试完感觉对枚举、接口还有集合的用法更熟了。 最重要的是理解： 先枚举 再定义接口 在重写实现方法 实验结果截图如下 ","date":"2025-10-28","objectID":"/posts/javaseexp-02/:0:0","tags":null,"title":"Javaseexp 02","uri":"/posts/javaseexp-02/"}]