[{"categories":null,"content":"DataLab 位运算实验详解 实验概述 实验目的： 熟悉和掌握计算机中整数和浮点数的二进制编码表示 实验环境： C语言编程环境 实验时间： 2025年10月23日 实验内容详解 第1关：bitAnd - 位与运算 知识点 德摩根定律： x \u0026 y = ~(~x | ~y) 位运算基础： 取反、或运算的应用 任务要求 补充函数bitAnd()，只用~，|实现x \u0026 y 操作符限制： ~，| 操作符数量限制： 8 解题思路 根据德摩根定律，位与运算可以通过取反和或运算来实现： 对x和y分别进行取反操作：~x，~y 对两个结果进行按位或运算：~x | ~y 对最终结果再次取反：~(~x | ~y) 代码实现 int bitAnd(int x, int y) { return ~(~x | ~y); } 第2关：getByte - 字节提取 知识点 字节编号： 从低位到高位从0开始编号 位偏移计算： 每个字节占8位，n号字节对应8n位偏移 掩码操作： 使用\u0026 0xFF提取最低8位 任务要求 补充函数getByte()，取出x中的n号字节 字节编号： 从低位到高位从0开始 操作符数量限制： 6 解题思路 计算位偏移量：n \u003c\u003c 3（相当于n * 8） 将x右移相应位数：x \u003e\u003e (n \u003c\u003c 3) 使用掩码0xFF提取最低8位：\u0026 0xFF 代码实现 int getByte(int x, int n) { return (x \u003e\u003e (n \u003c\u003c 3)) \u0026 0xFF; } 示例分析 对于x = 0x12345678： 字节3：0x12（最高位字节） 字节2：0x34 字节1：0x56 字节0：0x78（最低位字节） 提取字节1：n \u003c\u003c 3 = 8，x \u003e\u003e 8 = 0x00123456，\u0026 0xFF = 0x56 第3关：logicalShift - 逻辑右移 知识点 逻辑右移： 高位补0 算术右移： 高位补符号位 掩码构造： 生成合适的掩码来清除符号位扩展 任务要求 补充函数logicalShift()，将x逻辑右移n位（0 ≤ n ≤ 31） 操作符数量限制： 20 解题思路 生成基准高位标志：1 \u003c\u003c 31（仅最高位为1） 对标志进行算术右移n位：(1 \u003c\u003c 31) \u003e\u003e n 取反得到掩码：~((1 \u003c\u003c 31) \u003e\u003e n) 对x进行算术右移后与掩码结合：(x \u003e\u003e n) \u0026 mask 代码实现 int m=1 \u003c\u003c 31; m=~((m \u003e\u003e n) \u003c\u003c 1); return (x \u003e\u003e n)\u0026 m; 第4关：bitCount - 位计数 知识点 位统计： 统计二进制表示中1的个数 位掩码： 使用左移操作生成位掩码 循环思想： 通过重复操作实现循环效果 任务要求 补充函数bitCount()，统计x的二进制表示中1的数量 解题思路 使用暴力方法，遍历每一位并统计1的个数： 初始化计数器为0 对于每一位i（0-31）： 生成位掩码：1 \u003c\u003c i 与x进行与运算：x \u0026 (1 \u003c\u003c i) 如果结果非0，计数器加1 代码实现 int ret = 0; for(int i=0; i\u003c32; i++){ if(x \u0026 (1\u003c\u003ci)){ ret++; } } return ret; 第5关：bang - 逻辑非运算 知识点 逻辑非特性： !x在x为0时返回1，x非0时返回0 补码特性： x和-x的符号位相反 符号位提取： 通过右移31位提取符号位 任务要求 补充函数bang()，实现逻辑非运算!x 操作符限制： ~ \u0026 ^ | + \u003c\u003c \u003e\u003e 操作符数量限制： 12 解题思路 利用补码特性：x | (-x) 当x = 0时，结果为0 当x ≠ 0时，结果的最高位为1 提取符号位：(x | (-x)) \u003e\u003e 31 调整结果：加1得到最终的逻辑非结果 代码实现 int bang(int x) { return ((x | (~x + 1)) \u003e\u003e 31) + 1; } 详细分析 x = 0： 0 | 0 = 0，0 \u003e\u003e 31 = 0，0 + 1 = 1 → 正确 x ≠ 0： x | (-x)最高位为1，\u003e\u003e 31得到-1，-1 + 1 = 0 → 正确 第6关：tmin - 最小补码整数 知识点 补码表示： 32位补码的最小值为-2^31 位操作： 通过左移操作生成最小值 任务要求 补充函数tmin()，返回补码表示的整型最小值 操作符数量限制： 4 解题思路 32位补码的最小值是-2^31，其二进制表示为最高位1，其余位0。通过1 \u003c\u003c 31可以直接生成这个值。 代码实现 int tmin(void) { return 1 \u003c\u003c 31; } 第7关：fitsBits - 位数适配检查 知识点 补码范围： n位补码的范围是[-2^(n-1), 2^(n-1)-1] 符号扩展： 左移再右移可以检验是否在范围内 任务要求 补充函数fitsBits()，如果x可以只用n位补码表示则返回1，否则返回0（1 ≤ n ≤ 32） 操作符数量限制： 15 解题思路 计算移位量：32 - n 左移后再右移：(x \u003c\u003c (32 - n)) \u003e\u003e (32 - n) 比较结果与原x是否相等：相等则在范围内 代码实现 int fitsBits(int x, int n) { return x == ((x \u003c\u003c (32 - n)) \u003e\u003e (32 - n)); } 第8关：divpwr2 - 除以2的幂 知识点 向零舍入： 正数向下舍入，负数向上舍入 偏移量修正： 负数需要添加偏移量来实现向零舍入 任务要求 补充函数divpwr2()，计算x / 2^n，结果向零取整（0 ≤ n ≤ 30） 操作符数量限制： 15 解题思路 生成偏移量：(1 \u003c\u003c n) - 1 提取符号位：x \u003e\u003e 31 计算修正值：(x \u003e\u003e 31) \u0026 ((1 \u003c\u003c n) - 1) 加偏移量后右移：(x + bias) \u003e\u003e n 代码实现 int divpwr2(int x, int n) { int bias = (x \u003e\u003e 31) \u0026 ((1 \u003c\u003c n) - 1); return (x + bias) \u003e\u003e n; } 第9关：negate - 取负数 知识点 补码取负： 补码的负数等于取反加1 位运算实现： ~x + 1 任务要求 补充函数negate()，计算-x 解题思路 根据补码的特性，一个数的负数等于它的取反加1：-x = ~x + 1 代码实现 int negate(int x) { return ~x + 1; } 第10关：isPositive - 正数判断 知识点 符号位检查： 最高位为0表示正数 非零检查： 需要排除x = 0的情况 任务要求 补充函数isPositive()，如果x大于0返回1，否则返回0 操作符数量限制： 8 解题思路 检查符号位：(x \u003e\u003e 31) \u0026 1 → 0表示非负 检查是否非零：!!x → 1表示非零 两者结合：(!((x \u003e\u003e 31) \u0026 1)) \u0026 (!!x) 代码实现 int isPositive(int x) { return !((x \u003e\u003e 31) \u0026 1) \u0026 (!!x); } 第11关：isLessOrEqual - 小于等于判断 知识点 符号比较： 不同符号的数比较 差值比较： 相同符号的数通过差值比较 任务要求 补充函数isLessOrEqual()，如果x小于等于y则返回1 操作符数量限制： 24 解题思路 符号不同： x负y正 → x ≤ y → 返回1 x正y负 → x \u003e y → 返回0 符号相同： 计算y - x 检查y - x的符号位 代码实现 int x1=x\u003e\u003e31; int y1=y\u003e\u003e31; int case1=x1\u0026!y1;//x负y正的情况 int temp=y+~x+1; //y-x int case2=(!(temp\u003e\u003e31))\u0026(!(x1^y1));//xy同号但是y-x大于0 return case1|case2; 第12关：ilog2 - 以2为底的对数 知识点 二进制最高位： 找到最高位1的位置 二分查找： 通过二分法快速定位最高位 任务要求 补充函数ilog2()，返回x以2为底的对数的整数部分 解题思路 使用二分法定位最高位1的位置： 检查高16位是否有1 检查高8位是否有1 继续检查4位、2位、1位 就是不断逼近逼近 代码实现 int ret = 0; if (x \u003e= (1 \u003c\u003c 16)) { ret += 16; x \u003e\u003e= 16; } if (x \u003e= (1 \u003c\u003c 8)) { ret += 8; x \u003e\u003e= 8; } if (x \u003e= (1 \u003c\u003c 4)) { ret += 4; x \u003e\u003e= 4; } if (x \u003e= (1 \u003c\u003c 2)) { ret += 2; x \u003e\u003e= 2; } if (x \u003e= (1 \u003c\u003c 1)) { ret += 1; x \u003e\u003e= 1; } return ret; 第13关：float_neg - 浮点数取负 知识点 IEEE 754浮点数： 符号位、阶码、尾数三部分组成 符号位操作： 取反符号位即可得到负数 任务要求 补充函数float_neg()，返回-f的位级表示 解题思路 提取符号位：uf \u003e\u003e 31 取反符号位：1 ^ (uf \u003e\u003e 31) 重组浮点数：(new_sign \u003c\u003c 31) | (uf \u0026 0x7FFFFFFF) 代码实现 unsigned int jieshu=(uf\u003e\u003e23)\u00260xFF; unsigned int weishu=uf\u00260x7FFFFF","date":"2025-10-29","objectID":"/posts/datalab%E8%AF%A6%E8%A7%A3/:0:0","tags":null,"title":"DataLab详解","uri":"/posts/datalab%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"javaseexp-02 首先得有花色和牌面吧，这俩都是固定的，所以用了枚举。花色就叫Suit，放了黑桃、红桃、梅花、方块；牌面是Face，从二到A，每个牌面还带了个value，比如A是14，这样后面比大小方便。代码大概是这样的： public enum Face { 二(2), 三(3), ..., A(14); // 中间省略了其他牌面 private int value; Face(int value) { this.value = value; } public int getValue() { return value; } } 然后是单张牌，用Card类来表示，里面就俩属性：suit（花色）和face（牌面）。构造方法传这俩参数，还得有getter方法拿属性。最开始写toString的时候直接用suit + face，结果打印出来不对，后来才知道枚举得用name()方法，改成suit.name() + face.name()就正常了，能显示“红桃七”这种格式。 public class Card { private Suit suit; private Face face; public Card(Suit suit, Face face) { this.suit = suit; this.face = face; } // getter方法省略 public String toString() { return suit.name() + face.name(); // 这里踩过坑，刚开始没加name() } } 牌组的话，写了个Poke类，负责生成牌。构造方法里用嵌套循环，外层控制几副牌，中间循环花色，内层循环牌面，每次循环就new一个Card加进列表里。这样不管要1副还是2副，传个参数就行。 发牌和洗牌的功能，有Action接口，定义了shuffle、distribute、display这几个方法，然后让Game类去实现。洗牌简单，用Collections.shuffle直接打乱列表就行。发牌的时候卡了一下，怎么让牌轮流分给每个玩家呢？后来想到用取余，index是当前牌的序号，index % player就能得到该发给第几个玩家，比如3个玩家的话，0%3=0（玩家1），1%3=1（玩家2），2%3=2（玩家3），3%3=0（又回到玩家1），代码是这样的： public void distribute(ArrayList\u003cCard\u003e cards, ArrayList\u003cArrayList\u003cCard\u003e\u003e playercards, int player) { int index = 0; for (Card card : cards) { playercards.get(index % player).add(card); // 取余实现轮流发牌 index++; } } 不过刚开始运行的时候报了空指针异常，调试了半天才发现，playercards里的每个玩家列表没初始化，只是new了个外层列表，里面的小列表还是null。后来在main里加了循环，给每个玩家new一个ArrayList，就好了： // 初始化玩家手牌列表，这里刚开始漏掉了，导致空指针 for (int i = 0; i \u003c players; i++) { playercards.add(new ArrayList\u003c\u003e()); } 比大小的时候，直接拿两张牌的face.getValue()比较就行，这个逻辑简单，没出什么问题。 整个流程就是：让用户输入几副牌、几个玩家，然后生成牌组、洗牌、发牌，最后显示每个玩家的牌，再随机抽两张比大小。运行起来还挺顺畅的，就是写的时候有些细节没注意，踩了几个小坑，调试完感觉对枚举、接口还有集合的用法更熟了。 最重要的是理解： 先枚举 再定义接口 在重写实现方法 实验结果截图如下 ","date":"2025-10-28","objectID":"/posts/javaseexp-02/:0:0","tags":null,"title":"Javaseexp 02","uri":"/posts/javaseexp-02/"}]