[{"categories":null,"content":"Javase基础笔记1.0——基于《狂神说Java》 1. 人机交互第一步：Scanner类（Java5新特性） 1.1 核心定位：解决“程序没人交互”的痛点 在学Scanner之前，我们写的程序都是“自说自话”（比如固定打印Hello World），而java.util.Scanner是Java提供的原生输入工具，能获取用户从控制台输入的文本、数字等内容。 1.2 完整使用流程（含资源关闭） Scanner的使用分5步，缺一不可（尤其是关闭资源，避免内存泄漏）： import java.util.Scanner; // 1. 导入Scanner包（IDEA会自动提示） public class ScannerDemo { public static void main(String[] args) { // 2. 创建Scanner对象，关联系统输入流（System.in = 控制台输入） Scanner scanner = new Scanner(System.in); // 3. 判断是否有输入（避免读取空数据抛异常） System.out.print(\"请输入你的姓名：\"); if (scanner.hasNextLine()) { // 判断是否有完整行输入 // 4. 读取输入内容 String name = scanner.nextLine(); System.out.println(\"你好，\" + name + \"！\"); } // 5. 关闭Scanner，释放输入流资源（必须做！） scanner.close(); } } 运行效果： 请输入你的姓名：张三 你好，张三！ 1.3 关键方法：判断与读取的“黄金搭档” Scanner的核心是“先判断，再读取”，避免直接读取导致的InputMismatchException（输入类型不匹配）。以下是常用方法对比： 方法类别 方法名 功能描述 适用场景 判断输入 hasNext() 判断后续是否有“有效字符”（非空格/Tab/Enter），返回boolean 读取不含空格的字符串 判断输入 hasNextLine() 判断后续是否有“完整行”（以Enter为结束符），返回boolean 读取含空格的字符串（如姓名） 判断输入 hasNextInt() 判断后续输入是否为整数，返回boolean 读取年龄、分数等int类型数据 判断输入 hasNextDouble() 判断后续输入是否为浮点数，返回boolean 读取工资、身高等double数据 读取输入 next() 读取“有效字符到空白字符”的字符串（不含空白） 读取用户名（无空格） 读取输入 nextLine() 读取“当前位置到Enter前”的所有字符（含空白） 读取地址、备注（含空格） 读取输入 nextInt() 读取整数并返回int，输入非整数会抛异常 读取整数 读取输入 nextDouble() 读取浮点数并返回double，输入非浮点数会抛异常 读取浮点数 1.4 深坑预警：next()与nextLine()的“兼容性问题” 这是入门最容易踩的坑！当next()和nextLine()连续使用时，nextLine()会“吃掉”next()残留的Enter，导致读取空字符串。 问题复现： Scanner scanner = new Scanner(System.in); System.out.print(\"请输入年龄：\"); int age = scanner.nextInt(); // 输入“25”后按Enter，缓冲区残留Enter System.out.print(\"请输入姓名：\"); String name = scanner.nextLine(); // 直接读取残留的Enter，返回空字符串 System.out.println(\"年龄：\" + age + \"，姓名：\" + name); // 姓名为空 运行效果： 请输入年龄：25 请输入姓名： 年龄：25，姓名： 解决方案（两种）： 方案1：额外调用nextLine()消耗Enter 在nextInt()后加一行scanner.nextLine();，手动清空缓冲区： int age = scanner.nextInt(); scanner.nextLine(); // 关键：消耗残留的Enter String name = scanner.nextLine(); // 正常读取姓名 方案2：统一用nextLine()读取，再手动转类型 避免混合使用不同读取方法，先读字符串再转成目标类型（更推荐，通用性强）： System.out.print(\"请输入年龄：\"); String ageStr = scanner.nextLine(); // 先读字符串 int age = Integer.parseInt(ageStr); // 转成int System.out.print(\"请输入姓名：\"); String name = scanner.nextLine(); // 正常读取 2. 方法进阶：可变参数——解决“参数数量不确定” 2.1 核心场景：当方法参数“可多可少”时 比如实现“求任意个数字的最大值”，如果没有可变参数，需要重载多个方法（max(int a)、max(int a,int b)、max(int a,int b,int c)），麻烦且不灵活。 JDK1.5引入的可变参数，允许方法接收“数量不固定的同类型参数”，本质是数组的语法糖（底层仍用数组存储）。 2.2 语法规则：3个“必须遵守” 声明格式：在参数类型后加省略号（...），参数名自定义（如numbers）； 数量限制：一个方法只能有1个可变参数（多了会歧义）； 位置限制：可变参数必须是方法的最后一个参数（普通参数需在前面）。 错误与正确示例对比： 语法示例 是否正确 原因分析 public static void printMax(double... numbers) ✅ 符合“类型+…+参数名”，无其他参数 public static void test(String name, int... scores) ✅ 可变参数在最后，普通参数在前面 public static void test(int... scores, String name) ❌ 可变参数不是最后一个参数 public static void test(int... a, double... b) ❌ 一个方法有2个可变参数，无法区分参数边界 2.3 实战案例：求任意个double数字的最大值 public class VariableArgsDemo { public static void main(String[] args) { // 调用可变参数方法：可传0个、1个、多个参数，或直接传数组 printMax(); // 无参数 printMax(1.5); // 1个参数 printMax(3.2, 5.8, 2.9, 4.1); // 多个参数 printMax(new double[]{1.1, 2.2, 3.3}); // 传数组（底层兼容） } // 可变参数方法：求最大值 public static void printMax(double... numbers) { // 1. 判断是否传入参数（numbers本质是数组，length=0表示无参数） if (numbers.length == 0) { System.out.println(\"⚠️ 未传入任何参数\"); return; // 结束方法，避免后续空指针 } // 2. 初始化最大值（取第一个参数） double max = numbers[0]; // 3. 遍历数组，对比更新最大值（原笔记标注“排序!”，遍历更高效） for (double num : numbers) { if (num \u003e max) { max = num; } } // 4. 输出结果 System.out.println(\"当前最大值：\" + max); } } 运行效果： ⚠️ 未传入任何参数 当前最大值：1.5 当前最大值：5.8 当前最大值：3.3 3. 底层核心：Java内存分析——搞懂“对象存在哪里” 这是Java的“灵魂知识点”，很多人学完面向对象还不清楚“new的对象存在哪”“引用变量是什么”。结合原笔记的ProcessOn配图，我们用Pet类实例拆解堆、栈、方法区的分工。 3.1 内存三分区：职责分明 Java内存主要分为堆（Heap）、栈（Stack）、方法区（Method Area，JDK8+为元空间），各分区存储内容和特性完全不同： 分区名称 存储内容（超详细版） 线程共享性 生命周期 堆（Heap） 1. 所有new创建的对象（如new Pet()、new Person()）； 2. 所有数组（如new int[5]）； 3. 对象的成员变量（随对象存储，有默认值） 可被所有线程共享 随对象创建而分配，随GC（垃圾回收）回收而释放（无需手动管理） 栈（Stack） 1. 基本类型变量（如int age=25，存储“25”这个具体数值）； 2. 引用类型变量（如Pet cat=new Pet()，存储“对象在堆中的地址”）； 3. 方法调用的栈帧（存储局部变量、操作数栈、返回地址） 线程私有（每个线程独立栈） 栈帧随方法调用创建，方法执行完出栈；变量随作用域（如代码块）结束而释放 方法区（Method Area） 1. 类的字节码信","date":"2025-11-11","objectID":"/posts/javase/:0:0","tags":null,"title":"Javase","uri":"/posts/javase/"},{"categories":null,"content":"DataLab 位运算实验详解 实验概述 实验目的： 熟悉和掌握计算机中整数和浮点数的二进制编码表示 实验环境： C语言编程环境 实验时间： 2025年10月23日 实验内容详解 第1关：bitAnd - 位与运算 知识点 德摩根定律： x \u0026 y = ~(~x | ~y) 位运算基础： 取反、或运算的应用 任务要求 补充函数bitAnd()，只用~，|实现x \u0026 y 操作符限制： ~，| 操作符数量限制： 8 解题思路 根据德摩根定律，位与运算可以通过取反和或运算来实现： 对x和y分别进行取反操作：~x，~y 对两个结果进行按位或运算：~x | ~y 对最终结果再次取反：~(~x | ~y) 代码实现 int bitAnd(int x, int y) { return ~(~x | ~y); } 第2关：getByte - 字节提取 知识点 字节编号： 从低位到高位从0开始编号 位偏移计算： 每个字节占8位，n号字节对应8n位偏移 掩码操作： 使用\u0026 0xFF提取最低8位 任务要求 补充函数getByte()，取出x中的n号字节 字节编号： 从低位到高位从0开始 操作符数量限制： 6 解题思路 计算位偏移量：n \u003c\u003c 3（相当于n * 8） 将x右移相应位数：x \u003e\u003e (n \u003c\u003c 3) 使用掩码0xFF提取最低8位：\u0026 0xFF 代码实现 int getByte(int x, int n) { return (x \u003e\u003e (n \u003c\u003c 3)) \u0026 0xFF; } 示例分析 对于x = 0x12345678： 字节3：0x12（最高位字节） 字节2：0x34 字节1：0x56 字节0：0x78（最低位字节） 提取字节1：n \u003c\u003c 3 = 8，x \u003e\u003e 8 = 0x00123456，\u0026 0xFF = 0x56 第3关：logicalShift - 逻辑右移 知识点 逻辑右移： 高位补0 算术右移： 高位补符号位 掩码构造： 生成合适的掩码来清除符号位扩展 任务要求 补充函数logicalShift()，将x逻辑右移n位（0 ≤ n ≤ 31） 操作符数量限制： 20 解题思路 生成基准高位标志：1 \u003c\u003c 31（仅最高位为1） 对标志进行算术右移n位：(1 \u003c\u003c 31) \u003e\u003e n 取反得到掩码：~((1 \u003c\u003c 31) \u003e\u003e n) 对x进行算术右移后与掩码结合：(x \u003e\u003e n) \u0026 mask 代码实现 int m=1 \u003c\u003c 31; m=~((m \u003e\u003e n) \u003c\u003c 1); return (x \u003e\u003e n)\u0026 m; 第4关：bitCount - 位计数 知识点 位统计： 统计二进制表示中1的个数 位掩码： 使用左移操作生成位掩码 循环思想： 通过重复操作实现循环效果 任务要求 补充函数bitCount()，统计x的二进制表示中1的数量 解题思路 使用暴力方法，遍历每一位并统计1的个数： 初始化计数器为0 对于每一位i（0-31）： 生成位掩码：1 \u003c\u003c i 与x进行与运算：x \u0026 (1 \u003c\u003c i) 如果结果非0，计数器加1 代码实现 int ret = 0; for(int i=0; i\u003c32; i++){ if(x \u0026 (1\u003c\u003ci)){ ret++; } } return ret; 第5关：bang - 逻辑非运算 知识点 逻辑非特性： !x在x为0时返回1，x非0时返回0 补码特性： x和-x的符号位相反 符号位提取： 通过右移31位提取符号位 任务要求 补充函数bang()，实现逻辑非运算!x 操作符限制： ~ \u0026 ^ | + \u003c\u003c \u003e\u003e 操作符数量限制： 12 解题思路 利用补码特性：x | (-x) 当x = 0时，结果为0 当x ≠ 0时，结果的最高位为1 提取符号位：(x | (-x)) \u003e\u003e 31 调整结果：加1得到最终的逻辑非结果 代码实现 int bang(int x) { return ((x | (~x + 1)) \u003e\u003e 31) + 1; } 详细分析 x = 0： 0 | 0 = 0，0 \u003e\u003e 31 = 0，0 + 1 = 1 → 正确 x ≠ 0： x | (-x)最高位为1，\u003e\u003e 31得到-1，-1 + 1 = 0 → 正确 第6关：tmin - 最小补码整数 知识点 补码表示： 32位补码的最小值为-2^31 位操作： 通过左移操作生成最小值 任务要求 补充函数tmin()，返回补码表示的整型最小值 操作符数量限制： 4 解题思路 32位补码的最小值是-2^31，其二进制表示为最高位1，其余位0。通过1 \u003c\u003c 31可以直接生成这个值。 代码实现 int tmin(void) { return 1 \u003c\u003c 31; } 第7关：fitsBits - 位数适配检查 知识点 补码范围： n位补码的范围是[-2^(n-1), 2^(n-1)-1] 符号扩展： 左移再右移可以检验是否在范围内 任务要求 补充函数fitsBits()，如果x可以只用n位补码表示则返回1，否则返回0（1 ≤ n ≤ 32） 操作符数量限制： 15 解题思路 计算移位量：32 - n 左移后再右移：(x \u003c\u003c (32 - n)) \u003e\u003e (32 - n) 比较结果与原x是否相等：相等则在范围内 代码实现 int fitsBits(int x, int n) { return x == ((x \u003c\u003c (32 - n)) \u003e\u003e (32 - n)); } 第8关：divpwr2 - 除以2的幂 知识点 向零舍入： 正数向下舍入，负数向上舍入 偏移量修正： 负数需要添加偏移量来实现向零舍入 任务要求 补充函数divpwr2()，计算x / 2^n，结果向零取整（0 ≤ n ≤ 30） 操作符数量限制： 15 解题思路 生成偏移量：(1 \u003c\u003c n) - 1 提取符号位：x \u003e\u003e 31 计算修正值：(x \u003e\u003e 31) \u0026 ((1 \u003c\u003c n) - 1) 加偏移量后右移：(x + bias) \u003e\u003e n 代码实现 int divpwr2(int x, int n) { int bias = (x \u003e\u003e 31) \u0026 ((1 \u003c\u003c n) - 1); return (x + bias) \u003e\u003e n; } 第9关：negate - 取负数 知识点 补码取负： 补码的负数等于取反加1 位运算实现： ~x + 1 任务要求 补充函数negate()，计算-x 解题思路 根据补码的特性，一个数的负数等于它的取反加1：-x = ~x + 1 代码实现 int negate(int x) { return ~x + 1; } 第10关：isPositive - 正数判断 知识点 符号位检查： 最高位为0表示正数 非零检查： 需要排除x = 0的情况 任务要求 补充函数isPositive()，如果x大于0返回1，否则返回0 操作符数量限制： 8 解题思路 检查符号位：(x \u003e\u003e 31) \u0026 1 → 0表示非负 检查是否非零：!!x → 1表示非零 两者结合：(!((x \u003e\u003e 31) \u0026 1)) \u0026 (!!x) 代码实现 int isPositive(int x) { return !((x \u003e\u003e 31) \u0026 1) \u0026 (!!x); } 第11关：isLessOrEqual - 小于等于判断 知识点 符号比较： 不同符号的数比较 差值比较： 相同符号的数通过差值比较 任务要求 补充函数isLessOrEqual()，如果x小于等于y则返回1 操作符数量限制： 24 解题思路 符号不同： x负y正 → x ≤ y → 返回1 x正y负 → x \u003e y → 返回0 符号相同： 计算y - x 检查y - x的符号位 代码实现 int x1=x\u003e\u003e31; int y1=y\u003e\u003e31; int case1=x1\u0026!y1;//x负y正的情况 int temp=y+~x+1; //y-x int case2=(!(temp\u003e\u003e31))\u0026(!(x1^y1));//xy同号但是y-x大于0 return case1|case2; 第12关：ilog2 - 以2为底的对数 知识点 二进制最高位： 找到最高位1的位置 二分查找： 通过二分法快速定位最高位 任务要求 补充函数ilog2()，返回x以2为底的对数的整数部分 解题思路 使用二分法定位最高位1的位置： 检查高16位是否有1 检查高8位是否有1 继续检查4位、2位、1位 就是不断逼近逼近 代码实现 int ret = 0; if (x \u003e= (1 \u003c\u003c 16)) { ret += 16; x \u003e\u003e= 16; } if (x \u003e= (1 \u003c\u003c 8)) { ret += 8; x \u003e\u003e= 8; } if (x \u003e= (1 \u003c\u003c 4)) { ret += 4; x \u003e\u003e= 4; } if (x \u003e= (1 \u003c\u003c 2)) { ret += 2; x \u003e\u003e= 2; } if (x \u003e= (1 \u003c\u003c 1)) { ret += 1; x \u003e\u003e= 1; } return ret; 第13关：float_neg - 浮点数取负 知识点 IEEE 754浮点数： 符号位、阶码、尾数三部分组成 符号位操作： 取反符号位即可得到负数 任务要求 补充函数float_neg()，返回-f的位级表示 解题思路 提取符号位：uf \u003e\u003e 31 取反符号位：1 ^ (uf \u003e\u003e 31) 重组浮点数：(new_sign \u003c\u003c 31) | (uf \u0026 0x7FFFFFFF) 代码实现 unsigned int jieshu=(uf\u003e\u003e23)\u00260xFF; unsigned int weishu=uf\u00260x7FFFFF","date":"2025-10-29","objectID":"/posts/datalab%E8%AF%A6%E8%A7%A3/:0:0","tags":null,"title":"DataLab详解","uri":"/posts/datalab%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"javaseexp-02 首先得有花色和牌面吧，这俩都是固定的，所以用了枚举。花色就叫Suit，放了黑桃、红桃、梅花、方块；牌面是Face，从二到A，每个牌面还带了个value，比如A是14，这样后面比大小方便。代码大概是这样的： public enum Face { 二(2), 三(3), ..., A(14); // 中间省略了其他牌面 private int value; Face(int value) { this.value = value; } public int getValue() { return value; } } 然后是单张牌，用Card类来表示，里面就俩属性：suit（花色）和face（牌面）。构造方法传这俩参数，还得有getter方法拿属性。最开始写toString的时候直接用suit + face，结果打印出来不对，后来才知道枚举得用name()方法，改成suit.name() + face.name()就正常了，能显示“红桃七”这种格式。 public class Card { private Suit suit; private Face face; public Card(Suit suit, Face face) { this.suit = suit; this.face = face; } // getter方法省略 public String toString() { return suit.name() + face.name(); // 这里踩过坑，刚开始没加name() } } 牌组的话，写了个Poke类，负责生成牌。构造方法里用嵌套循环，外层控制几副牌，中间循环花色，内层循环牌面，每次循环就new一个Card加进列表里。这样不管要1副还是2副，传个参数就行。 发牌和洗牌的功能，有Action接口，定义了shuffle、distribute、display这几个方法，然后让Game类去实现。洗牌简单，用Collections.shuffle直接打乱列表就行。发牌的时候卡了一下，怎么让牌轮流分给每个玩家呢？后来想到用取余，index是当前牌的序号，index % player就能得到该发给第几个玩家，比如3个玩家的话，0%3=0（玩家1），1%3=1（玩家2），2%3=2（玩家3），3%3=0（又回到玩家1），代码是这样的： public void distribute(ArrayList\u003cCard\u003e cards, ArrayList\u003cArrayList\u003cCard\u003e\u003e playercards, int player) { int index = 0; for (Card card : cards) { playercards.get(index % player).add(card); // 取余实现轮流发牌 index++; } } 不过刚开始运行的时候报了空指针异常，调试了半天才发现，playercards里的每个玩家列表没初始化，只是new了个外层列表，里面的小列表还是null。后来在main里加了循环，给每个玩家new一个ArrayList，就好了： // 初始化玩家手牌列表，这里刚开始漏掉了，导致空指针 for (int i = 0; i \u003c players; i++) { playercards.add(new ArrayList\u003c\u003e()); } 比大小的时候，直接拿两张牌的face.getValue()比较就行，这个逻辑简单，没出什么问题。 整个流程就是：让用户输入几副牌、几个玩家，然后生成牌组、洗牌、发牌，最后显示每个玩家的牌，再随机抽两张比大小。运行起来还挺顺畅的，就是写的时候有些细节没注意，踩了几个小坑，调试完感觉对枚举、接口还有集合的用法更熟了。 最重要的是理解： 先枚举 再定义接口 在重写实现方法 实验结果截图如下 ","date":"2025-10-28","objectID":"/posts/javaseexp-02/:0:0","tags":null,"title":"Javaseexp 02","uri":"/posts/javaseexp-02/"}]