[{"categories":["笔记"],"content":"Java 笔记3.0 八、常用类与集合框架：Java 开发的“工具箱”（续） 二、集合框架：Java 存储数据的“容器”（续） 3. List 接口：有序可重复集合 List 接口的核心是“有序、可重复、支持索引访问”，常用实现类为 ArrayList 和 LinkedList，两者底层结构不同，导致性能差异显著。 （1）ArrayList：动态数组实现（查询优先） 底层结构：基于动态数组（JDK 8 无初始容量时默认空数组，第一次添加元素时扩容为 10；JDK 7 初始容量默认 10），数组满时自动扩容（扩容机制：JDK 8 及后为原容量的 1.5 倍，JDK 7 为 1.5 倍+1）。 核心特点： 优势：支持通过索引（get(int index)）直接访问元素，查询效率高（时间复杂度 O(1)）； 劣势：增删元素时需移动数组元素（如在中间插入元素，需后移后续所有元素），增删效率低（时间复杂度 O(n)）； 线程安全：线程不安全（多线程并发修改可能抛出 ConcurrentModificationException）。 常用方法（除 Collection 通用方法外）： E get(int index)：通过索引获取元素； E set(int index, E element)：替换指定索引的元素； void add(int index, E element)：在指定索引插入元素； E remove(int index)：删除指定索引的元素； int indexOf(Object o)：返回元素首次出现的索引（无则返回 -1）。 代码示例（ArrayList 用法） import java.util.ArrayList; import java.util.List; public class ArrayListDemo { public static void main(String[] args) { // 1. 创建 ArrayList 集合（泛型指定存储 String 类型） List\u003cString\u003e list = new ArrayList\u003c\u003e(); // 2. 添加元素 list.add(\"Java\"); list.add(\"Python\"); list.add(\"C++\"); System.out.println(\"初始集合：\" + list); // 输出：[Java, Python, C++] // 3. 索引访问 String first = list.get(0); System.out.println(\"索引 0 的元素：\" + first); // 输出：Java // 4. 插入元素（索引 1 位置） list.add(1, \"Go\"); System.out.println(\"插入后集合：\" + list); // 输出：[Java, Go, Python, C++] // 5. 修改元素（索引 2 位置） list.set(2, \"JavaScript\"); System.out.println(\"修改后集合：\" + list); // 输出：[Java, Go, JavaScript, C++] // 6. 删除元素（索引 3 位置） list.remove(3); System.out.println(\"删除后集合：\" + list); // 输出：[Java, Go, JavaScript] // 7. 遍历集合（三种方式） // 方式 1：普通 for 循环（利用索引） System.out.println(\"普通 for 循环遍历：\"); for (int i = 0; i \u003c list.size(); i++) { System.out.print(list.get(i) + \" \"); // 输出：Java Go JavaScript } // 方式 2：增强 for 循环（foreach） System.out.println(\"\\n增强 for 循环遍历：\"); for (String lang : list) { System.out.print(lang + \" \"); } // 方式 3：迭代器（Iterator） System.out.println(\"\\n迭代器遍历：\"); java.util.Iterator\u003cString\u003e it = list.iterator(); while (it.hasNext()) { // 判断是否有下一个元素 String lang = it.next(); // 获取下一个元素 System.out.print(lang + \" \"); } } } （2）LinkedList：双向链表实现（增删优先） 底层结构：基于双向链表（每个节点包含 prev（前驱）、element（元素）、next（后继）），无需连续内存空间。 核心特点： 优势：增删元素时只需修改链表节点的 prev 和 next 指针，增删效率高（尤其是首尾操作，时间复杂度 O(1)）； 劣势：查询元素需从链表头/尾遍历，查询效率低（时间复杂度 O(n)）； 线程安全：线程不安全； 额外功能：实现 Deque 接口，可作为队列（FIFO）或栈（LIFO）使用。 常用方法（除 List 通用方法外，新增首尾操作）： void addFirst(E e)：在链表头部添加元素； void addLast(E e)：在链表尾部添加元素（等同于 add(E e)）； E getFirst()：获取头部元素； E getLast()：获取尾部元素； E removeFirst()：删除头部元素； E removeLast()：删除尾部元素。 代码示例（LinkedList 作为队列和栈） import java.util.LinkedList; import java.util.Queue; import java.util.Deque; public class LinkedListDemo { public static void main(String[] args) { // 1. 作为队列（先进先出，FIFO） Queue\u003cString\u003e queue = new LinkedList\u003c\u003e(); queue.offer(\"A\"); // 入队（尾部添加） queue.offer(\"B\"); queue.offer(\"C\"); System.out.println(\"队列初始：\" + queue); // 输出：[A, B, C] String pollElem = queue.poll(); // 出队（头部删除） System.out.println(\"出队元素：\" + pollElem); // 输出：A System.out.println(\"出队后队列：\" + queue); // 输出：[B, C] // 2. 作为栈（先进后出，LIFO） Deque\u003cString\u003e stack = new LinkedList\u003c\u003e(); stack.push(\"X\"); // 入栈（头部添加） stack.push(\"Y\"); stack.push(\"Z\"); System.out.println(\"栈初始：\" + stack); // 输出：[Z, Y, X] String popElem = stack.pop(); // 出栈（头部删除） System.out.println(\"出栈元素：\" + popElem); // 输出：Z System.out.println(\"出栈后栈：\" + stack); // 输出：[Y, X] } } （3）ArrayList vs LinkedList 对比选择 对比维度 ArrayList LinkedList 底层结构 动态数组 双向链表 查询效率 高（O(1)，索引访问） 低（O(n)，遍历访问） 增删效率 低（O(n)，移动元素） 高（O(1)，首尾操作；O(n)，中间操作） 内存占用 可能有冗余（数组扩容预留空间） 无冗余（节点按需创建） 适用场景 频繁查询、少量增删（如数据展示） 频繁增删、少量查询（如队列/栈） 4. Set 接口：无序不可重复集合 Set 接口的核心是“无序（存储顺序与添加顺序无关）、不可重复（元素唯一）、无索引”，常用实现类为 HashSet、LinkedHashSet、TreeSet。 （1）HashSet：哈希表实现（无序去重） 底层结构：JDK 8 前为“数组+链表”，JDK 8 及后为“数组+链表/红黑树”（当链表长度超过 8 且数组容量≥64 时，链表转为红黑树，提升查询效率）。 去重原理：基于 hashCode() 和 equals() 方法，核心逻辑： 新增元素时，先调用元素的 hashCode() 方法，计算哈希值，确定在数组中的存储位置； 若该位置为空，直接存入元素； 若该位置不为空，调用该位置已有元素的 equals() 方法与新增元素比较： 若 equals() 返回 true，视为重复元素，不存入； 若 equals() 返回 false，存入链表（或红黑树）。 重要约定：若重写 equals() 方法，必须同时重写 hashCode() 方法，确保“相等的对象必须有相等的哈希值”（否则会导致 HashSet 无法去重）。 核心特点：无序、不可重复、查询效率高（平均 O(1)）、线程不安全。 代码示例（HashSet 去重与重写方法） import java.util.HashSet; import ","date":"2025-11-17","objectID":"/posts/86f3bbb/:0:0","tags":["笔记"],"title":"Java笔记3.0","uri":"/posts/86f3bbb/"},{"categories":["笔记"],"content":"Java 笔记2.0 一、super 与 this 关键字：对象与父类的“桥梁” 1. 核心本质与作用 this：代表当前对象实例的引用，本质是“指向当前正在执行方法的对象”，用于访问本类的属性、方法、构造器。 super：代表父类对象的引用（非父类实例，而是子类对象中父类的“部分”），用于访问父类的属性、方法、构造器，仅存在于继承场景。 2. 构造方法中的使用（重点） （1）调用规则 无论是 this()（调用本类构造）还是 super()（调用父类构造），必须放在构造方法的第一行（否则编译报错）。 super() 和 this() 不能同时出现（因为第一行只能有一个，且两者都需占第一行）。 若子类构造中未显式调用 super()，编译器会默认添加 super()（调用父类无参构造），若父类无无参构造，则必须显式调用父类有参构造。 （2）代码示例 // 父类 class Father { private String name; // 父类无参构造 public Father() { System.out.println(\"Father 无参构造执行\"); } // 父类有参构造 public Father(String name) { this.name = name; System.out.println(\"Father 有参构造执行，name=\" + name); } } // 子类 class Son extends Father { private int age; // 子类无参构造 public Son() { // 编译器默认添加 super()，调用父类无参构造 System.out.println(\"Son 无参构造执行\"); } // 子类有参构造 public Son(String fatherName, int age) { super(fatherName); // 显式调用父类有参构造（必须在第一行） this.age = age; // this 访问本类属性 System.out.println(\"Son 有参构造执行，age=\" + age); } // this 调用本类其他构造 public Son(int age) { this(\"张三\", age); // 调用本类的 Son(String, int) 构造（必须在第一行） } } // 测试 public class Test { public static void main(String[] args) { Son son1 = new Son(); // 输出：Father 无参构造执行 → Son 无参构造执行 Son son2 = new Son(\"李四\", 18); // 输出：Father 有参构造执行，name=李四 → Son 有参构造执行，age=18 } } 3. 访问属性与方法的用法 场景 语法示例 说明 访问本类属性 this.属性名 若局部变量与属性重名，必须用 this 区分 访问父类属性 super.属性名 需保证父类属性访问权限（非 private） 调用本类方法 this.方法名(参数) 可省略 this（无歧义时） 调用父类方法 super.方法名(参数) 用于调用父类未被重写的方法 代码示例 class Father { protected String familyName = \"张\"; // 父类受保护属性 public void sayFamily() { System.out.println(\"家族姓氏：\" + familyName); } } class Son extends Father { private String familyName = \"李\"; // 子类与父类属性重名（隐藏父类属性） @Override public void sayFamily() { System.out.println(\"子类姓氏：\" + this.familyName); // 访问子类属性 System.out.println(\"父类姓氏：\" + super.familyName); // 访问父类属性 super.sayFamily(); // 调用父类方法 } } public class Test { public static void main(String[] args) { Son son = new Son(); son.sayFamily(); // 输出： // 子类姓氏：李 // 父类姓氏：张 // 家族姓氏：张 } } 4. 核心区别对比 对比维度 this super 代表对象 当前对象实例 父类对象的引用（子类中的父类部分） 使用前提 无继承也可使用（只要是对象） 必须存在继承关系 访问构造器 this()：调用本类构造 super()：调用父类构造 访问属性/方法 优先访问本类，无则向上找 直接访问父类 与构造器的关系 可调用本类其他构造，需在第一行 可调用父类构造，需在第一行 5. 易错点总结 super() 必须在构造第一行：若放在后面，编译直接报错（Java 语法强制）。 父类无无参构造时，子类必须显式调用父类有参构造：否则编译器默认添加的 super() 会找不到父类无参构造，报 NoSuchMethodError。 this 不能在静态方法中使用：静态方法属于类，无对象实例，而 this 依赖对象；super 同理，也不能在静态方法中使用。 二、静态（static）与非静态成员：类与对象的“边界” 1. 核心概念与内存模型 静态成员（static 修饰）：包括静态属性、静态方法，属于类本身，存储在 方法区的静态区，仅加载一次（类加载时初始化），所有对象共享。 非静态成员：包括非静态属性、非静态方法，属于对象实例，存储在 堆内存，每个对象有独立副本，需创建对象后访问。 2. 静态成员的特性与用法 （1）静态属性（类变量） 初始化时机：类加载时（早于对象创建），默认值与非静态属性一致（如 int 为 0，String 为 null）。 访问方式：类名.静态属性名（推荐）或 对象.静态属性名（不推荐，易混淆）。 应用场景：存储共享数据（如计数器、常量）。 （2）静态方法（类方法） 访问限制：不能直接访问非静态成员（非静态成员依赖对象，静态方法无对象），但可访问静态成员；不能使用 this/super。 访问方式：类名.静态方法名(参数)（推荐）或 对象.静态方法名(参数)。 应用场景：工具类方法（如 Math.random()、Arrays.sort()）、无状态方法（不依赖对象属性）。 代码示例 class Tool { // 静态属性（共享计数器） public static int count = 0; // 静态方法（工具方法） public static int add(int a, int b) { count++; // 静态方法访问静态属性 return a + b; } // 非静态方法 public void showCount() { System.out.println(\"调用次数：\" + count); // 非静态方法可访问静态属性 } } public class Test { public static void main(String[] args) { // 静态方法直接通过类名调用 int sum1 = Tool.add(1, 2); int sum2 = Tool.add(3, 4); // 静态属性通过类名访问 System.out.println(\"静态属性 count：\" + Tool.count); // 输出 2 // 非静态方法需创建对象调用 Tool tool = new Tool(); tool.showCount(); // 输出 调用次数：2 } } 3. 静态 vs 非静态：关键区别 对比维度 静态成员（static） 非静态成员 所属对象 类本身 对象实例 内存位置 方法区静态区 堆内存 加载时机 类加载时 对象创建时 访问方式 类名.成员（推荐） 对象.成员（必须） 访问权限 不能访问非静态成员 可访问静态/非静态成员 this/super 不能使用 可以使用 共享性 所有对象共享 每个对象独立 4. 静态方法与多态的关系（重点易错点） 静态方法不参与多态：方法调用时，编译器根据“引用的类型”（而非对象实际类型）确定调用的方法，即“静态绑定”（编译时确定）。 代码示例（结合继承） class Father { public static void test() { System.out.println(\"Father 静态 test()\"); } } class Son extends Father { public static void test() { System.out.println(\"Son 静态 test()\"); } } public class Test { public static void main(String[] args) { Father f1 = new Father(); Father f2 = new Son(); // 父类引用指向子类对象 Son s1 = new Son(); f1.test(); // 输出 Father 静态 test()（引用类型是 Father） f2.test(); // 输出 Father 静态 test()（引用类型是 Father，不","date":"2025-11-17","objectID":"/posts/54c6db0/:0:0","tags":["笔记"],"title":"Java笔记2.0","uri":"/posts/54c6db0/"},{"categories":null,"content":"Javase基础笔记1.0——基于《狂神说Java》 1. 人机交互第一步：Scanner类（Java5新特性） 1.1 核心定位：解决“程序没人交互”的痛点 在学Scanner之前，我们写的程序都是“自说自话”（比如固定打印Hello World），而java.util.Scanner是Java提供的原生输入工具，能获取用户从控制台输入的文本、数字等内容。 1.2 完整使用流程（含资源关闭） Scanner的使用分5步，缺一不可（尤其是关闭资源，避免内存泄漏）： import java.util.Scanner; // 1. 导入Scanner包（IDEA会自动提示） public class ScannerDemo { public static void main(String[] args) { // 2. 创建Scanner对象，关联系统输入流（System.in = 控制台输入） Scanner scanner = new Scanner(System.in); // 3. 判断是否有输入（避免读取空数据抛异常） System.out.print(\"请输入你的姓名：\"); if (scanner.hasNextLine()) { // 判断是否有完整行输入 // 4. 读取输入内容 String name = scanner.nextLine(); System.out.println(\"你好，\" + name + \"！\"); } // 5. 关闭Scanner，释放输入流资源（必须做！） scanner.close(); } } 运行效果： 请输入你的姓名：张三 你好，张三！ 1.3 关键方法：判断与读取的“黄金搭档” Scanner的核心是“先判断，再读取”，避免直接读取导致的InputMismatchException（输入类型不匹配）。以下是常用方法对比： 方法类别 方法名 功能描述 适用场景 判断输入 hasNext() 判断后续是否有“有效字符”（非空格/Tab/Enter），返回boolean 读取不含空格的字符串 判断输入 hasNextLine() 判断后续是否有“完整行”（以Enter为结束符），返回boolean 读取含空格的字符串（如姓名） 判断输入 hasNextInt() 判断后续输入是否为整数，返回boolean 读取年龄、分数等int类型数据 判断输入 hasNextDouble() 判断后续输入是否为浮点数，返回boolean 读取工资、身高等double数据 读取输入 next() 读取“有效字符到空白字符”的字符串（不含空白） 读取用户名（无空格） 读取输入 nextLine() 读取“当前位置到Enter前”的所有字符（含空白） 读取地址、备注（含空格） 读取输入 nextInt() 读取整数并返回int，输入非整数会抛异常 读取整数 读取输入 nextDouble() 读取浮点数并返回double，输入非浮点数会抛异常 读取浮点数 1.4 深坑预警：next()与nextLine()的“兼容性问题” 这是入门最容易踩的坑！当next()和nextLine()连续使用时，nextLine()会“吃掉”next()残留的Enter，导致读取空字符串。 问题复现： Scanner scanner = new Scanner(System.in); System.out.print(\"请输入年龄：\"); int age = scanner.nextInt(); // 输入“25”后按Enter，缓冲区残留Enter System.out.print(\"请输入姓名：\"); String name = scanner.nextLine(); // 直接读取残留的Enter，返回空字符串 System.out.println(\"年龄：\" + age + \"，姓名：\" + name); // 姓名为空 运行效果： 请输入年龄：25 请输入姓名： 年龄：25，姓名： 解决方案（两种）： 方案1：额外调用nextLine()消耗Enter 在nextInt()后加一行scanner.nextLine();，手动清空缓冲区： int age = scanner.nextInt(); scanner.nextLine(); // 关键：消耗残留的Enter String name = scanner.nextLine(); // 正常读取姓名 方案2：统一用nextLine()读取，再手动转类型 避免混合使用不同读取方法，先读字符串再转成目标类型（更推荐，通用性强）： System.out.print(\"请输入年龄：\"); String ageStr = scanner.nextLine(); // 先读字符串 int age = Integer.parseInt(ageStr); // 转成int System.out.print(\"请输入姓名：\"); String name = scanner.nextLine(); // 正常读取 2. 方法进阶：可变参数——解决“参数数量不确定” 2.1 核心场景：当方法参数“可多可少”时 比如实现“求任意个数字的最大值”，如果没有可变参数，需要重载多个方法（max(int a)、max(int a,int b)、max(int a,int b,int c)），麻烦且不灵活。 JDK1.5引入的可变参数，允许方法接收“数量不固定的同类型参数”，本质是数组的语法糖（底层仍用数组存储）。 2.2 语法规则：3个“必须遵守” 声明格式：在参数类型后加省略号（...），参数名自定义（如numbers）； 数量限制：一个方法只能有1个可变参数（多了会歧义）； 位置限制：可变参数必须是方法的最后一个参数（普通参数需在前面）。 错误与正确示例对比： 语法示例 是否正确 原因分析 public static void printMax(double... numbers) ✅ 符合“类型+…+参数名”，无其他参数 public static void test(String name, int... scores) ✅ 可变参数在最后，普通参数在前面 public static void test(int... scores, String name) ❌ 可变参数不是最后一个参数 public static void test(int... a, double... b) ❌ 一个方法有2个可变参数，无法区分参数边界 2.3 实战案例：求任意个double数字的最大值 public class VariableArgsDemo { public static void main(String[] args) { // 调用可变参数方法：可传0个、1个、多个参数，或直接传数组 printMax(); // 无参数 printMax(1.5); // 1个参数 printMax(3.2, 5.8, 2.9, 4.1); // 多个参数 printMax(new double[]{1.1, 2.2, 3.3}); // 传数组（底层兼容） } // 可变参数方法：求最大值 public static void printMax(double... numbers) { // 1. 判断是否传入参数（numbers本质是数组，length=0表示无参数） if (numbers.length == 0) { System.out.println(\"⚠️ 未传入任何参数\"); return; // 结束方法，避免后续空指针 } // 2. 初始化最大值（取第一个参数） double max = numbers[0]; // 3. 遍历数组，对比更新最大值（原笔记标注“排序!”，遍历更高效） for (double num : numbers) { if (num \u003e max) { max = num; } } // 4. 输出结果 System.out.println(\"当前最大值：\" + max); } } 运行效果： ⚠️ 未传入任何参数 当前最大值：1.5 当前最大值：5.8 当前最大值：3.3 3. 底层核心：Java内存分析——搞懂“对象存在哪里” 这是Java的“灵魂知识点”，很多人学完面向对象还不清楚“new的对象存在哪”“引用变量是什么”。结合原笔记的ProcessOn配图，我们用Pet类实例拆解堆、栈、方法区的分工。 3.1 内存三分区：职责分明 Java内存主要分为堆（Heap）、栈（Stack）、方法区（Method Area，JDK8+为元空间），各分区存储内容和特性完全不同： 分区名称 存储内容（超详细版） 线程共享性 生命周期 堆（Heap） 1. 所有new创建的对象（如new Pet()、new Person()）； 2. 所有数组（如new int[5]）； 3. 对象的成员变量（随对象存储，有默认值） 可被所有线程共享 随对象创建而分配，随GC（垃圾回收）回收而释放（无需手动管理） 栈（Stack） 1. 基本类型变量（如int age=25，存储“25”这个具体数值）； 2. 引用类型变量（如Pet cat=new Pet()，存储“对象在堆中的地址”）； 3. 方法调用的栈帧（存储局部变量、操作数栈、返回地址） 线程私有（每个线程独立栈） 栈帧随方法调用创建，方法执行完出栈；变量随作用域（如代码块）结束而释放 方法区（Method Area） 1. 类的字节码信","date":"2025-11-11","objectID":"/posts/java%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"Javase","uri":"/posts/java%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"DataLab 位运算实验详解 实验概述 实验目的： 熟悉和掌握计算机中整数和浮点数的二进制编码表示 实验环境： C语言编程环境 实验时间： 2025年10月23日 实验内容详解 第1关：bitAnd - 位与运算 知识点 德摩根定律： x \u0026 y = ~(~x | ~y) 位运算基础： 取反、或运算的应用 任务要求 补充函数bitAnd()，只用~，|实现x \u0026 y 操作符限制： ~，| 操作符数量限制： 8 解题思路 根据德摩根定律，位与运算可以通过取反和或运算来实现： 对x和y分别进行取反操作：~x，~y 对两个结果进行按位或运算：~x | ~y 对最终结果再次取反：~(~x | ~y) 代码实现 int bitAnd(int x, int y) { return ~(~x | ~y); } 第2关：getByte - 字节提取 知识点 字节编号： 从低位到高位从0开始编号 位偏移计算： 每个字节占8位，n号字节对应8n位偏移 掩码操作： 使用\u0026 0xFF提取最低8位 任务要求 补充函数getByte()，取出x中的n号字节 字节编号： 从低位到高位从0开始 操作符数量限制： 6 解题思路 计算位偏移量：n \u003c\u003c 3（相当于n * 8） 将x右移相应位数：x \u003e\u003e (n \u003c\u003c 3) 使用掩码0xFF提取最低8位：\u0026 0xFF 代码实现 int getByte(int x, int n) { return (x \u003e\u003e (n \u003c\u003c 3)) \u0026 0xFF; } 示例分析 对于x = 0x12345678： 字节3：0x12（最高位字节） 字节2：0x34 字节1：0x56 字节0：0x78（最低位字节） 提取字节1：n \u003c\u003c 3 = 8，x \u003e\u003e 8 = 0x00123456，\u0026 0xFF = 0x56 第3关：logicalShift - 逻辑右移 知识点 逻辑右移： 高位补0 算术右移： 高位补符号位 掩码构造： 生成合适的掩码来清除符号位扩展 任务要求 补充函数logicalShift()，将x逻辑右移n位（0 ≤ n ≤ 31） 操作符数量限制： 20 解题思路 生成基准高位标志：1 \u003c\u003c 31（仅最高位为1） 对标志进行算术右移n位：(1 \u003c\u003c 31) \u003e\u003e n 取反得到掩码：~((1 \u003c\u003c 31) \u003e\u003e n) 对x进行算术右移后与掩码结合：(x \u003e\u003e n) \u0026 mask 代码实现 int m=1 \u003c\u003c 31; m=~((m \u003e\u003e n) \u003c\u003c 1); return (x \u003e\u003e n)\u0026 m; 第4关：bitCount - 位计数 知识点 位统计： 统计二进制表示中1的个数 位掩码： 使用左移操作生成位掩码 循环思想： 通过重复操作实现循环效果 任务要求 补充函数bitCount()，统计x的二进制表示中1的数量 解题思路 使用暴力方法，遍历每一位并统计1的个数： 初始化计数器为0 对于每一位i（0-31）： 生成位掩码：1 \u003c\u003c i 与x进行与运算：x \u0026 (1 \u003c\u003c i) 如果结果非0，计数器加1 代码实现 int ret = 0; for(int i=0; i\u003c32; i++){ if(x \u0026 (1\u003c\u003ci)){ ret++; } } return ret; 第5关：bang - 逻辑非运算 知识点 逻辑非特性： !x在x为0时返回1，x非0时返回0 补码特性： x和-x的符号位相反 符号位提取： 通过右移31位提取符号位 任务要求 补充函数bang()，实现逻辑非运算!x 操作符限制： ~ \u0026 ^ | + \u003c\u003c \u003e\u003e 操作符数量限制： 12 解题思路 利用补码特性：x | (-x) 当x = 0时，结果为0 当x ≠ 0时，结果的最高位为1 提取符号位：(x | (-x)) \u003e\u003e 31 调整结果：加1得到最终的逻辑非结果 代码实现 int bang(int x) { return ((x | (~x + 1)) \u003e\u003e 31) + 1; } 详细分析 x = 0： 0 | 0 = 0，0 \u003e\u003e 31 = 0，0 + 1 = 1 → 正确 x ≠ 0： x | (-x)最高位为1，\u003e\u003e 31得到-1，-1 + 1 = 0 → 正确 第6关：tmin - 最小补码整数 知识点 补码表示： 32位补码的最小值为-2^31 位操作： 通过左移操作生成最小值 任务要求 补充函数tmin()，返回补码表示的整型最小值 操作符数量限制： 4 解题思路 32位补码的最小值是-2^31，其二进制表示为最高位1，其余位0。通过1 \u003c\u003c 31可以直接生成这个值。 代码实现 int tmin(void) { return 1 \u003c\u003c 31; } 第7关：fitsBits - 位数适配检查 知识点 补码范围： n位补码的范围是[-2^(n-1), 2^(n-1)-1] 符号扩展： 左移再右移可以检验是否在范围内 任务要求 补充函数fitsBits()，如果x可以只用n位补码表示则返回1，否则返回0（1 ≤ n ≤ 32） 操作符数量限制： 15 解题思路 计算移位量：32 - n 左移后再右移：(x \u003c\u003c (32 - n)) \u003e\u003e (32 - n) 比较结果与原x是否相等：相等则在范围内 代码实现 int fitsBits(int x, int n) { return x == ((x \u003c\u003c (32 - n)) \u003e\u003e (32 - n)); } 第8关：divpwr2 - 除以2的幂 知识点 向零舍入： 正数向下舍入，负数向上舍入 偏移量修正： 负数需要添加偏移量来实现向零舍入 任务要求 补充函数divpwr2()，计算x / 2^n，结果向零取整（0 ≤ n ≤ 30） 操作符数量限制： 15 解题思路 生成偏移量：(1 \u003c\u003c n) - 1 提取符号位：x \u003e\u003e 31 计算修正值：(x \u003e\u003e 31) \u0026 ((1 \u003c\u003c n) - 1) 加偏移量后右移：(x + bias) \u003e\u003e n 代码实现 int divpwr2(int x, int n) { int bias = (x \u003e\u003e 31) \u0026 ((1 \u003c\u003c n) - 1); return (x + bias) \u003e\u003e n; } 第9关：negate - 取负数 知识点 补码取负： 补码的负数等于取反加1 位运算实现： ~x + 1 任务要求 补充函数negate()，计算-x 解题思路 根据补码的特性，一个数的负数等于它的取反加1：-x = ~x + 1 代码实现 int negate(int x) { return ~x + 1; } 第10关：isPositive - 正数判断 知识点 符号位检查： 最高位为0表示正数 非零检查： 需要排除x = 0的情况 任务要求 补充函数isPositive()，如果x大于0返回1，否则返回0 操作符数量限制： 8 解题思路 检查符号位：(x \u003e\u003e 31) \u0026 1 → 0表示非负 检查是否非零：!!x → 1表示非零 两者结合：(!((x \u003e\u003e 31) \u0026 1)) \u0026 (!!x) 代码实现 int isPositive(int x) { return !((x \u003e\u003e 31) \u0026 1) \u0026 (!!x); } 第11关：isLessOrEqual - 小于等于判断 知识点 符号比较： 不同符号的数比较 差值比较： 相同符号的数通过差值比较 任务要求 补充函数isLessOrEqual()，如果x小于等于y则返回1 操作符数量限制： 24 解题思路 符号不同： x负y正 → x ≤ y → 返回1 x正y负 → x \u003e y → 返回0 符号相同： 计算y - x 检查y - x的符号位 代码实现 int x1=x\u003e\u003e31; int y1=y\u003e\u003e31; int case1=x1\u0026!y1;//x负y正的情况 int temp=y+~x+1; //y-x int case2=(!(temp\u003e\u003e31))\u0026(!(x1^y1));//xy同号但是y-x大于0 return case1|case2; 第12关：ilog2 - 以2为底的对数 知识点 二进制最高位： 找到最高位1的位置 二分查找： 通过二分法快速定位最高位 任务要求 补充函数ilog2()，返回x以2为底的对数的整数部分 解题思路 使用二分法定位最高位1的位置： 检查高16位是否有1 检查高8位是否有1 继续检查4位、2位、1位 就是不断逼近逼近 代码实现 int ret = 0; if (x \u003e= (1 \u003c\u003c 16)) { ret += 16; x \u003e\u003e= 16; } if (x \u003e= (1 \u003c\u003c 8)) { ret += 8; x \u003e\u003e= 8; } if (x \u003e= (1 \u003c\u003c 4)) { ret += 4; x \u003e\u003e= 4; } if (x \u003e= (1 \u003c\u003c 2)) { ret += 2; x \u003e\u003e= 2; } if (x \u003e= (1 \u003c\u003c 1)) { ret += 1; x \u003e\u003e= 1; } return ret; 第13关：float_neg - 浮点数取负 知识点 IEEE 754浮点数： 符号位、阶码、尾数三部分组成 符号位操作： 取反符号位即可得到负数 任务要求 补充函数float_neg()，返回-f的位级表示 解题思路 提取符号位：uf \u003e\u003e 31 取反符号位：1 ^ (uf \u003e\u003e 31) 重组浮点数：(new_sign \u003c\u003c 31) | (uf \u0026 0x7FFFFFFF) 代码实现 unsigned int jieshu=(uf\u003e\u003e23)\u00260xFF; unsigned int weishu=uf\u00260x7FFFFF","date":"2025-10-29","objectID":"/posts/datalab%E8%AF%A6%E8%A7%A3/:0:0","tags":null,"title":"DataLab详解","uri":"/posts/datalab%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"javaseexp-02 首先得有花色和牌面吧，这俩都是固定的，所以用了枚举。花色就叫Suit，放了黑桃、红桃、梅花、方块；牌面是Face，从二到A，每个牌面还带了个value，比如A是14，这样后面比大小方便。代码大概是这样的： public enum Face { 二(2), 三(3), ..., A(14); // 中间省略了其他牌面 private int value; Face(int value) { this.value = value; } public int getValue() { return value; } } 然后是单张牌，用Card类来表示，里面就俩属性：suit（花色）和face（牌面）。构造方法传这俩参数，还得有getter方法拿属性。最开始写toString的时候直接用suit + face，结果打印出来不对，后来才知道枚举得用name()方法，改成suit.name() + face.name()就正常了，能显示“红桃七”这种格式。 public class Card { private Suit suit; private Face face; public Card(Suit suit, Face face) { this.suit = suit; this.face = face; } // getter方法省略 public String toString() { return suit.name() + face.name(); // 这里踩过坑，刚开始没加name() } } 牌组的话，写了个Poke类，负责生成牌。构造方法里用嵌套循环，外层控制几副牌，中间循环花色，内层循环牌面，每次循环就new一个Card加进列表里。这样不管要1副还是2副，传个参数就行。 发牌和洗牌的功能，有Action接口，定义了shuffle、distribute、display这几个方法，然后让Game类去实现。洗牌简单，用Collections.shuffle直接打乱列表就行。发牌的时候卡了一下，怎么让牌轮流分给每个玩家呢？后来想到用取余，index是当前牌的序号，index % player就能得到该发给第几个玩家，比如3个玩家的话，0%3=0（玩家1），1%3=1（玩家2），2%3=2（玩家3），3%3=0（又回到玩家1），代码是这样的： public void distribute(ArrayList\u003cCard\u003e cards, ArrayList\u003cArrayList\u003cCard\u003e\u003e playercards, int player) { int index = 0; for (Card card : cards) { playercards.get(index % player).add(card); // 取余实现轮流发牌 index++; } } 不过刚开始运行的时候报了空指针异常，调试了半天才发现，playercards里的每个玩家列表没初始化，只是new了个外层列表，里面的小列表还是null。后来在main里加了循环，给每个玩家new一个ArrayList，就好了： // 初始化玩家手牌列表，这里刚开始漏掉了，导致空指针 for (int i = 0; i \u003c players; i++) { playercards.add(new ArrayList\u003c\u003e()); } 比大小的时候，直接拿两张牌的face.getValue()比较就行，这个逻辑简单，没出什么问题。 整个流程就是：让用户输入几副牌、几个玩家，然后生成牌组、洗牌、发牌，最后显示每个玩家的牌，再随机抽两张比大小。运行起来还挺顺畅的，就是写的时候有些细节没注意，踩了几个小坑，调试完感觉对枚举、接口还有集合的用法更熟了。 最重要的是理解： 先枚举 再定义接口 在重写实现方法 实验结果截图如下 ","date":"2025-10-28","objectID":"/posts/javaseexp-02/:0:0","tags":null,"title":"Javaseexp 02","uri":"/posts/javaseexp-02/"}]